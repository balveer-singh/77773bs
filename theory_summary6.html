<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Plain Text Code Display</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to right, #74ebd5, #acb6e5);
      padding: 2rem;
      text-align: center;
    }
    .container {
      background: white;
      max-width: 900px;
      margin: auto;
      padding: 2rem;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }
    h1 {
      color: #5964ff;
      margin-bottom: 1rem;
    }
    #output {
      text-align: left;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      background: #f4f4f4;
      border-left: 5px solid #5964ff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      color: #333;
    }
    textarea {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>JAVA</h1>
    <div id="output"></div>

    <!-- ✅ Raw unescaped code safely stored -->
    <textarea id="raw-input">
कोर JAVA के साथ ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग (OOP)
ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग (OOP) एक प्रोग्रामिंग पैरेडाइम (शैली) है जो कुछ महत्वपूर्ण सिद्धांतों पर आधारित होता है, जैसे कि:
•	इनहेरिटेंस (Inheritance)
•	डाटा बाइंडिंग (Data Binding)
•	पॉलिमॉर्फिज़्म (Polymorphism)
•	एब्स्ट्रैक्शन (Abstraction)
•	एनकैप्सुलेशन (Encapsulation)
इस पैरेडाइम में हर चीज़ को एक ऑब्जेक्ट के रूप में देखा जाता है, जिससे यह एक "सच्चा" ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग लैंग्वेज बनता है।
________________________________________
OOP बनाम प्रोसिजरियल प्रोग्रामिंग (Procedural Programming)
OOP में कई लाभ होते हैं जो इसे पारंपरिक (procedural) प्रोग्रामिंग से बेहतर बनाते हैं:
1.	OOP कोड चलाना आसान और तेज़ होता है।
2.	OOP आपके प्रोग्राम को एक स्पष्ट संरचना (structure) प्रदान करता है।
3.	DRY सिद्धांत (Don't Repeat Yourself) को अपनाता है – यानी कोड को दोहराने की जरूरत नहीं होती, जिससे कोड को समझना, बदलना और डिबग करना आसान होता है।
4.	OOP के ज़रिए आप पुन: उपयोग योग्य (reusable) एप्लिकेशन बना सकते हैं, जिससे कम कोड में काम होता है और डेवलपमेंट का समय भी कम लगता है।
________________________________________
OOPS क्या है (What is OOPS in Java)?
OOPS एक ऐसा दृष्टिकोण है जिसमें डाटा और उससे संबंधित फंक्शंस को एक साथ ऑब्जेक्ट के रूप में जोड़ा जाता है। इसका उद्देश्य है:
•	डेटा की सुरक्षा (Security)
•	कोड की पुन: उपयोगिता (Reusability)
•	रीयल वर्ल्ड मॉडलिंग (Real-world resemblance)
________________________________________
OOPS के मुख्य सिद्धांत (Core Concepts of OOPS in Java):
1. ऑब्जेक्ट (Object)
•	किसी भी ऐसी चीज़ को ऑब्जेक्ट कहा जा सकता है जिसके पास कोई स्थिति (State) और व्यवहार (Behavior) होता है।
•	उदाहरण: कुर्सी, पेन, कार, मोबाइल आदि।
•	ऑब्जेक्ट क्लास का इंस्टेंस (Instance) होता है।
•	यह मेमोरी में स्थान लेता है और अन्य ऑब्जेक्ट्स से बिना उनके अंदरूनी विवरण जाने संवाद कर सकता है।
2. क्लास (Class)
•	क्लास को ब्लूप्रिंट या खाका कहा जा सकता है।
•	यह ऑब्जेक्ट्स का एक समूह होता है जो समान गुण रखते हैं।
•	यह एक लॉजिकल एंटिटी है, कोई भौतिक वस्तु नहीं।
•	उदाहरण: एक "Expensive Cars" नाम की क्लास हो सकती है, जिससे Mercedes, BMW जैसे ऑब्जेक्ट्स बन सकते हैं।
3. इनहेरिटेंस (Inheritance)
•	यह वह प्रक्रिया है जिसमें एक क्लास दूसरी क्लास के गुणों और व्यवहारों को प्राप्त कर लेती है।
•	इससे कोड दोबारा लिखने की जरूरत नहीं होती (Code Reusability)।
•	उदाहरण: एक "Employee" क्लास हो सकती है, जिससे "Manager" क्लास इनहेरिट करे। मैनेजर के पास कर्मचारी के सभी गुण होंगे, साथ ही कुछ अतिरिक्त गुण जैसे – subordinate कर्मचारियों की सूची।
4. पॉलिमॉर्फिज़्म (Polymorphism)
•	इसका मतलब है एक ही नाम के साथ कई रूप (Many Forms)।
•	उदाहरण: एक ही नाम से दो फंक्शन लेकिन अलग पैरामीटर के साथ – यह compile-time polymorphism (method overloading) कहलाता है।
•	रनटाइम में, एक ही मेथड का अलग-अलग क्लास द्वारा अलग कार्य करना – यह runtime polymorphism (method overriding) कहलाता है।
5. एब्स्ट्रैक्शन (Abstraction)
•	इसका मतलब है उपयोगकर्ता को केवल आवश्यक जानकारी दिखाना और गैर-ज़रूरी विवरण छिपाना।
•	उदाहरण: ATM से पैसे निकालते वक्त आप इंटरफ़ेस पर कुछ ऑप्शन चुनते हैं, लेकिन बैकएंड में क्या हो रहा है – यह जानकारी आपसे छिपी रहती है।
6. एनकैप्सुलेशन (Encapsulation)
•	डेटा और कोड को एक साथ एक यूनिट में बांधना – इस प्रक्रिया को एनकैप्सुलेशन कहते हैं।
•	उदाहरण: एक कैप्सूल जिसमें अलग-अलग दवाएं एक साथ बंद होती हैं।
•	यह डेटा को सुरक्षित (Secure) रखने में मदद करता है, ताकि कोई बाहरी क्लास बिना अनुमति के डेटा में बदलाव न कर सके।
________________________________________
OOPS के अतिरिक्त महत्वपूर्ण टर्म्स (Other Important OOP Terms)
1. Coupling (कपलिंग)
•	यह बताता है कि दो क्लासेज़ एक-दूसरे पर कितनी निर्भर हैं।
•	Loose Coupling बेहतर मानी जाती है क्योंकि इससे क्लासेज़ को स्वतंत्र रूप से बदला जा सकता है।
2. Cohesion (कोहेज़न)
•	यह दर्शाता है कि किसी क्लास के सारे मेथड्स और डेटा एक-दूसरे से कितने संबंधित हैं।
•	High Cohesion अच्छी होती है क्योंकि क्लास एक ही उद्देश्य को पूरा करती है।
3. Association (एसोसिएशन)
•	दो क्लासेज़ के बीच का संबंध दर्शाता है।
•	उदाहरण: एक छात्र और उसके कॉलेज के बीच का संबंध।
4. Aggregation (एग्रीगेशन)
•	यह एक "has-a" संबंध को दर्शाता है, लेकिन दोनों क्लास स्वतंत्र रह सकती हैं।
•	उदाहरण: एक लाइब्रेरी में किताबें होती हैं, लेकिन किताब लाइब्रेरी से स्वतंत्र है।
5. Composition (कॉम्पोजिशन)
•	यह भी "has-a" संबंध है लेकिन ज्यादा मजबूती से जुड़ा होता है।
•	अगर बाहरी क्लास नष्ट होती है, तो आंतरिक क्लास भी नष्ट हो जाती है।
•	उदाहरण: एक शरीर (Body) और उसका दिल (Heart)।
✅ Java Programming की विशेषताएं (Features of Java Programming)
Java एक शक्तिशाली, सुरक्षित और पोर्टेबल प्रोग्रामिंग भाषा है जिसे विशेष रूप से इंटरनेट और नेटवर्क-आधारित एप्लिकेशन के लिए डिज़ाइन किया गया है।
🔸 1. Simple (सरल)
•	Java को सीखना और समझना आसान है।
•	इसमें जटिल चीजें जैसे पॉइंटर और मल्टी इनहेरिटेंस नहीं हैं (जैसे C++)।
•	Java में C और C++ की कई सुविधाएं ली गई हैं, जिससे C/C++ जानने वालों के लिए यह और आसान हो जाती है।
🔸 2. Secure (सुरक्षित)
•	Java में सुरक्षा के लिए मजबूत मेकैनिज़्म होते हैं।
•	Java एप्लिकेशन अन्य सिस्टम को हानि नहीं पहुंचा सकते।
•	यह इंटरनेट एप्लिकेशन को सुरक्षित रूप से डेवेलप और एक्सेस करने की सुविधा देता है।
🔸 3. Portable (पोर्टेबल)
•	Java कोड किसी भी प्लेटफॉर्म पर चल सकता है जहाँ JVM (Java Virtual Machine) हो।
•	उदाहरण: Linux, Windows, Mac आदि सभी जगह एक ही Java प्रोग्राम बिना बदले चल सकता है।
🔸 4. Object-Oriented (ऑब्जेक्ट-ओरिएंटेड)
•	Java पूरी तरह से OOP (Object Oriented Programming) आधारित है।
•	यह real-world को objects के रूप में represent करने की सुविधा देता है।
•	C++ के विपरीत, Java पूरी तरह object-oriented है (C++ आंशिक रूप से है)।
🔸 5. Robust (मजबूत)
•	Java error-free कोडिंग को बढ़ावा देता है।
•	यह compile time और runtime पर errors को चेक करता है।
•	इसमें memory management का बेहतरीन सिस्टम है (जैसे Garbage Collector)।
🔸 6. Multithreaded (मल्टीथ्रेडेड)
•	Java में multithreading का built-in support है।
•	यानी आप एक साथ कई tasks (threads) को एक ही प्रोग्राम में efficiently चला सकते हैं।
🔸 7. Architecture-Neutral (मशीन स्वतंत्र)
•	Java किसी विशेष हार्डवेयर या OS पर निर्भर नहीं है।
•	Java bytecode को किसी भी सिस्टम पर JVM के माध्यम से चलाया जा सकता है।
🔸 8. Interpreted (इंटरप्रेटेड)
•	Java का कोड पहले bytecode में compile होता है और फिर JVM द्वारा interpret किया जाता है।
•	यह feature Java को cross-platform बनाता है।
🔸 9. Distributed (वितरित)
•	Java नेटवर्क आधारित एप्लिकेशन के लिए उपयुक्त है।
•	Java में RMI (Remote Method Invocation) और EJB जैसे features हैं जो distributed systems को support करते हैं।
🔸 10. High Performance (उच्च प्रदर्शन)
•	Java bytecode को high performance के लिए ऑप्टिमाइज़ किया गया है।
•	हालांकि यह C/C++ जितना तेज़ नहीं है, लेकिन इसमें performance tuning संभव है।
________________________________________
🔷 Java के Object-Oriented Concepts (OOPS Concepts in Java)
✅ Object (वस्तु)
•	कोई भी ऐसी चीज़ जिसके पास स्थिति (State) और व्यवहार (Behavior) हो।
•	उदाहरण: कुर्सी, पेन, मोबाइल, कार आदि।
•	Java में, object क्लास का instance होता है।
✅ Class (क्लास)
•	क्लास एक ब्लूप्रिंट है जिससे object बनाए जाते हैं।
•	उदाहरण: "Car" नाम की क्लास से "BMW", "Toyota", "Honda" जैसे object बन सकते हैं।
✅ Inheritance (इनहेरिटेंस)
•	एक क्लास दूसरी क्लास से गुण और व्यवहार विरासत में लेती है।
•	इससे कोड का पुन: उपयोग (Reusability) होता है।
•	उदाहरण: Manager एक Employee है लेकिन उसके पास कुछ अतिरिक्त जिम्मेदारियाँ होती हैं।
✅ Polymorphism (पॉलिमॉर्फिज़्म)
•	एक ही नाम के functions या objects के अलग-अलग रूप हो सकते हैं।
•	Java में method overloading और method overriding इसका उदाहरण हैं।
✅ Abstraction (एब्स्ट्रैक्शन)
•	उपयोगकर्ता को केवल जरूरी जानकारी देना और बाकी को छिपाना।
•	उदाहरण: ATM इस्तेमाल करते समय आपको बैंक के बैकएंड प्रोसेस की जानकारी नहीं होती।
✅ Encapsulation (एनकैप्सुलेशन)
•	डेटा और उससे संबंधित कोड को एक साथ एक unit में बांधना।
•	यह सुरक्षा प्रदान करता है और डेटा को एक्सेस नियंत्रित करता है।
________________________________________
⚙️ Java के अन्य मुख्य Keywords (Mentioned in Content):
शब्द	अर्थ
CONCURRENCY	Java एक साथ कई कार्य करने (Multi-threading) को सपोर्ट करता है।
FUNCTIONAL	Java 8 से functional programming जैसे लैम्ब्डा एक्सप्रेशन को सपोर्ट करता है।
FAMILIAR	C/C++ जैसी संरचना होने से Java जाना-पहचाना महसूस होता है।
SECURE	Web और नेटवर्क एप्लिकेशन के लिए सुरक्षित वातावरण प्रदान करता है।
INDEPENDENT	हार्डवेयर और OS से स्वतंत्र; JVM आधारित।
SMP (Symmetric multiprocessing)	Java multi-core प्रोसेसर का लाभ उठाता है।
🧠 Java की मूलभूत संरचना (Core Components of Java)
________________________________________
🔶 1. JDK (Java Development Kit) – जावा डेवेलपमेंट किट
यह Java प्रोग्राम डेवलप करने का टूलकिट है।
✔️ इसमें क्या-क्या होता है:
•	Java Compiler (javac):
यह .java फाइल को bytecode में बदलता है, जो .class फाइल होती है।
•	JRE (Java Runtime Environment):
यह JDK का हिस्सा होता है और Java प्रोग्राम को चलाने (run) के लिए जरूरी होता है।
•	Development Tools:
जैसे debugger, javadoc, JavaFX tools आदि।
👉 JDK का उपयोग डेवलपर्स द्वारा किया जाता है Java कोड लिखने, कंपाइल करने और पैकेज करने के लिए।
________________________________________
🔶 2. JRE (Java Runtime Environment) – जावा रनटाइम एनवायरनमेंट
JRE का उपयोग Java प्रोग्राम को रन (चलाने) के लिए किया जाता है।
✔️ इसमें क्या शामिल है:
•	JVM (Java Virtual Machine):
जो bytecode को मशीन कोड में बदल कर रन करता है।
•	Core Java Libraries (Java API):
इनपुट/आउटपुट, नेटवर्किंग, डेटा स्ट्रक्चर आदि के लिए।
👉 अगर आप सिर्फ Java एप्लिकेशन को चलाना चाहते हैं (बिना कोड लिखे), तो सिर्फ JRE इंस्टॉल करना पर्याप्त है।
________________________________________
🔶 3. JVM (Java Virtual Machine) – जावा वर्चुअल मशीन
JVM Java bytecode को एक्चुअल मशीन कोड में बदल कर रन करता है।
✔️ JVM क्या करता है:
•	Bytecode Load करता है (ClassLoader के ज़रिए)
•	Verify करता है कि bytecode सुरक्षित है या नहीं
•	Execute करता है bytecode को
•	Memory Manage करता है (Heap, Stack, Garbage Collection)
•	Security सुनिश्चित करता है (Class loader restrictions)
👉 JVM की वजह से Java Platform Independent है – यानी एक बार कोड लिखो, हर जगह चलाओ ("Write Once, Run Anywhere").
________________________________________
🧾 Java Bytecode क्या है?
Java source file (.java) को जब हम compile करते हैं, तो यह .class फाइल बनती है, जिसमें bytecode होता है।
•	यह intermediate code होता है, जो ना पूरी तरह मशीन कोड है, ना high-level language।
•	JVM इसी bytecode को पढ़ता और execute करता है।
•	Bytecode = Java का "मशीन कोड", जिसे JVM समझ सकता है।
✅ Bytecode की विशेषता:
•	यही bytecode Java को Platform Independent बनाता है।
•	JVM अलग-अलग OS (Windows, Linux, Mac) पर इस bytecode को रन कर सकता है।
________________________________________
🏗️ JVM की Architecture (संरचना)
JVM के अंदर कई भाग होते हैं, जिनमें हर एक का अपना काम होता है:
🔸 1. Class Loader Subsystem
•	.class फाइल को लोड करता है और JVM के लिए तैयार करता है।
🔸 2. Runtime Data Areas (Memory Areas):
Memory Area	काम
Method Area / Class Area	सभी क्लास की जानकारी यहाँ स्टोर होती है।
Heap Area	सभी ऑब्जेक्ट्स और इंस्टेंस वेरिएबल्स यहाँ रहते हैं।
Stack Area	हर थ्रेड का अपना स्टैक होता है, जिसमें मेथड कॉल्स की जानकारी होती है।
Program Counter (PC) Register	यह बताता है कि कौन सा instruction अभी चल रहा है।
Native Method Stack	Native (non-Java) methods की जानकारी और execution के लिए।
🔸 3. Execution Engine
•	Bytecode को मशीन कोड में बदलता है और चलाता है।
•	इसमें Interpreter और JIT Compiler (Just-In-Time) होता है।
🔸 4. Java Native Interface (JNI)
•	Java को Native code (C/C++) से जोड़ने की सुविधा देता है।
🔸 5. Java Native Libraries
•	Native code में लिखे गए libraries जिन्हें JVM उपयोग करता है।
________________________________________
📁 PATH और CLASSPATH का महत्व
________________________________________
🔹 PATH क्या है?
यह एक सिस्टम Environment Variable होता है जिससे आप किसी भी डायरेक्टरी से Java commands (जैसे javac, java) चला सकते हैं।
✅ उदाहरण:
बिना PATH सेट किए:
C:\Java\jdk1.8.0\bin\javac DemoClass.java
PATH सेट करने के बाद:
javac DemoClass.java
👉 PATH सेट करना Java commands को globally एक्सेस करने के लिए जरूरी है।
________________________________________
🔹 CLASSPATH क्या है?
यह JVM और Java Compiler को बताता है कि कहाँ से .class फाइल्स या libraries लोड करनी हैं।
•	इसका उपयोग external .jar files, compiled class files को locate करने के लिए किया जाता है।
✅ उदाहरण:
set CLASSPATH = C:\Program Files\Java\jdk1.8.0\lib;
________________________________________
🔁 Java प्रोग्राम कैसे चलता है? (Execution Flow)
1.	आप .java फाइल बनाते हैं।
2.	javac कमांड से इसे compile करते हैं – यह .class फाइल बनाता है (Bytecode)।
3.	java कमांड से .class फाइल JVM द्वारा रन होती है।
4.	JVM bytecode को machine code में बदलता है और execute करता है।
________________________________________
🔚 निष्कर्ष (Conclusion)
कंपोनेंट	उद्देश्य
JDK	Java एप्लिकेशन बनाने (develop) के लिए – इसमें JRE और dev tools दोनों होते हैं
JRE	Java एप्लिकेशन को सिर्फ रन करने के लिए – इसमें JVM और core libraries होती हैं
JVM	Java bytecode को execute करने का environment
Bytecode	Java का compiled intermediate code जो JVM को दिया जाता है
PATH	System variable – Java tools को command line से चलाने में मदद करता है
CLASSPATH	Java को बताता है कि .class files या libraries कहां से लोड करनी हैं
🧾 Java Program Development की चरणबद्ध प्रक्रिया
Java का सिद्धांत है “Write Once, Run Anywhere”, यानी एक बार कोड लिखिए और उसे किसी भी प्लेटफ़ॉर्म पर चला सकते हैं जहाँ JVM उपलब्ध है।
________________________________________
✅ 1. JDK (Java Development Kit) इंस्टॉल करें
•	Java प्रोग्राम बनाने और चलाने के लिए JDK जरूरी है।
•	इसे आप Oracle की वेबसाइट या OpenJDK से डाउनलोड कर सकते हैं।
•	इंस्टॉल करने के बाद, JDK के bin फोल्डर को PATH Environment Variable में जोड़ें ताकि आप कमांड लाइन से javac, java जैसी commands चला सकें।
________________________________________
✅ 2. टेक्स्ट एडिटर या IDE चुनें
आप Java कोड दो तरीकों से लिख सकते हैं:
विकल्प	विवरण
Text Editor	जैसे Notepad, Notepad++ (सादा और सरल)
IDE (Integrated Development Environment)	जैसे IntelliJ IDEA, Eclipse, VS Code (सुविधाजनक और प्रोफेशनल)
IDE को चुनना बेहतर होता है क्योंकि ये आपको:
•	Auto-completion
•	Syntax highlighting
•	Debugging tools
•	Project structure देने में मदद करता है।
________________________________________
✅ 3. Java कोड लिखें
अब आप एक .java एक्सटेंशन वाली फाइल बनाइए।
उदाहरण के लिए: MyProgram.java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
________________________________________
✅ 4. फाइल को सेव करें
•	फाइल को उसी नाम से सेव करें जो आपने class में दिया है।
•	यानी, अगर आपकी class का नाम MyProgram है, तो फाइल का नाम होना चाहिए:
👉 MyProgram.java
________________________________________
✅ 5. कोड को Compile करें
Command Prompt / Terminal खोलिए और उस फोल्डर में जाइए जहाँ आपकी .java फाइल सेव है।
फिर यह कमांड चलाइए:
javac MyProgram.java
•	अगर कोई एरर नहीं है, तो एक .class फाइल बनेगी:
👉 MyProgram.class
यह फाइल Java Bytecode होती है जो JVM द्वारा रन की जाती है।
________________________________________
✅ 6. प्रोग्राम को Execute (चलाएं)
अब आप Java प्रोग्राम रन करने के लिए यह कमांड लिखें:
java MyProgram
⚠️ ध्यान दें: .class एक्सटेंशन नहीं लिखना है।
✔️ आउटपुट:
Hello, World!
________________________________________
✅ 7. डिबगिंग और टेस्टिंग करें
•	अगर प्रोग्राम में गलती है तो आप इसे debug कर सकते हैं।
•	शुरुआती लेवल पर आप System.out.println() का इस्तेमाल करके वैल्यूज चेक कर सकते हैं।
•	अगर आप IDE इस्तेमाल कर रहे हैं तो आप Breakpoints, Step Over, Watch Variables जैसे advanced tools का उपयोग कर सकते हैं।
________________________________________
✅ 8. पैकेजिंग और Distribution (वैकल्पिक)
अगर आप अपना प्रोग्राम दूसरों को देना चाहते हैं, तो आप इसे .jar (Java Archive) फाइल में पैक कर सकते हैं।
JAR फाइल बनाने का तरीका:
jar cf MyProgram.jar MyProgram.class
अब कोई भी जिसके पास Java हो, वह इस .jar को चला सकता है:
java -jar MyProgram.jar
________________________________________
📌 संक्षेप में Step-by-Step Process (Table Format)
चरण	कार्य
1	JDK इंस्टॉल करें और PATH सेट करें
2	टेक्स्ट एडिटर या IDE चुनें
3	.java फाइल बनाएं और कोड लिखें
4	फाइल को सेव करें
5	javac से कोड Compile करें
6	java कमांड से कोड Run करें
7	Debug और Test करें
8	ज़रूरत हो तो .jar फाइल बनाकर शेयर करें
________________________________________
🔧 उदाहरण (Hello World Java Program)
// MyProgram.java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
Compile:
javac MyProgram.java
Run:
java MyProgram
💻 Java Program को Compile और Execute करने की पूरी प्रक्रिया (Step-by-Step in Hindi)
________________________________________
✅ 1. Java Development Kit (JDK) इंस्टॉल करें
•	Java प्रोग्राम बनाने और रन करने के लिए JDK जरूरी है।
•	इसे आप Oracle या OpenJDK की वेबसाइट से डाउनलोड कर सकते हैं।
•	JDK इंस्टॉल करने के बाद, उसके bin फोल्डर को PATH environment variable में सेट करें।
🔹 PATH सेट करने का फायदा:
आप किसी भी फोल्डर से javac और java कमांड चला सकते हैं।
________________________________________
✅ 2. Text Editor या IDE का चयन करें
आप Java कोड लिखने के लिए निम्न में से कोई भी विकल्प चुन सकते हैं:
विकल्प	उपयोगिता
Notepad / Notepad++	बेसिक कोड एडिटिंग
IDE (जैसे Eclipse, IntelliJ IDEA, VS Code)	Auto-complete, Debugging, GUI support, Error hints आदि
🔹 IDE का उपयोग सीखने में मदद करता है और समय बचाता है।
________________________________________
✅ 3. Java कोड लिखें
अब एक .java फाइल बनाएं, जैसे:
File name: MyProgram.java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
🔸 यहाँ MyProgram class का नाम है, और यह main() मेथड से शुरू होता है, जो Java का entry point है।
________________________________________
✅ 4. Java फाइल सेव करें
•	उस फोल्डर में सेव करें जहां से आप इसे बाद में compile करेंगे।
•	फाइल का नाम क्लास के नाम के समान होना चाहिए।
उदाहरण: MyProgram.java में public class MyProgram होना चाहिए।
________________________________________
✅ 5. Java कोड Compile करें
Command Prompt / Terminal खोलें और उस फोल्डर में जाएं जहाँ .java फाइल सेव है।
Command:
javac MyProgram.java
✔️ यह कमांड .java फाइल को .class (bytecode) में बदल देगी।
Output:
MyProgram.class नाम की फाइल बन जाएगी।
________________________________________
✅ 6. Java प्रोग्राम Execute करें (Run करें)
अब आप compiled प्रोग्राम को चलाने के लिए java कमांड चलाएं:
Command:
java MyProgram
🔸 ध्यान दें कि .class एक्सटेंशन नहीं लगाना है।
Output:

Hello, World!
________________________________________
✅ 7. Debugging और Testing करें
प्रोग्राम में error होने पर आप:
•	System.out.println() का इस्तेमाल करके intermediate values print कर सकते हैं।
•	IDE में breakpoints लगाकर step-by-step debugging कर सकते हैं।
________________________________________
✅ 8. Java Program का Distribution (जरूरत पर)
अगर आप प्रोग्राम को दूसरों के साथ शेयर करना चाहते हैं:
•	आप .class फाइल्स या पूरी एप्लिकेशन को .jar (Java Archive) फाइल में पैक कर सकते हैं।
JAR फाइल बनाने की कमांड:
jar cf MyProgram.jar MyProgram.class
Run jar file:
java -jar MyProgram.jar
________________________________________
🔁 संक्षिप्त प्रक्रिया (Quick Summary Table)
चरण	विवरण
1	JDK इंस्टॉल करें और PATH सेट करें
2	Editor या IDE चुनें
3	Java कोड लिखें (.java फाइल में)
4	फाइल सेव करें
5	javac से Compile करें
6	java से Run करें
7	Debug और Test करें
8	JAR फाइल बनाकर Distribute करें (यदि आवश्यक हो)
________________________________________
✅ Example Output Screenshot (Text):
C:\JavaProjects> javac MyProgram.java
C:\JavaProjects> java MyProgram
Hello, World!
🔹 1. Keywords (कीवर्ड्स)
Java में keywords वे शब्द होते हैं जिनका विशेष अर्थ होता है और जो पहले से भाषा में परिभाषित होते हैं। इन्हें आप किसी वेरिएबल, क्लास, या मेथड के नाम की तरह उपयोग नहीं कर सकते।
✅ मुख्य विशेषताएँ:
•	सभी कीवर्ड lowercase (छोटे अक्षरों) में होते हैं
•	Java में लगभग 50 से अधिक कीवर्ड्स होते हैं
•	इन्हें पहचान कर Java Compiler आपके कोड की संरचना समझता है
🔸 Java Keywords की सूची:
abstract      assert       boolean      break        byte
case          catch        char         class        const
continue      default      do           double       else
enum          extends      final        finally      float
for           goto         if           implements   import
instanceof    int          interface    long         native
new           null         package      private      protected
public        return       short        static       strictfp
super         switch       synchronized this         throw
throws        transient    try          void         volatile
while
👉 Note: goto और const अभी उपयोग नहीं होते, लेकिन रिज़र्व किए गए हैं।
________________________________________
🔹 2. Comments (टिप्पणियाँ)
Java में comments प्रोग्राम में व्याख्या या नोट्स के लिए लिखे जाते हैं जिन्हें compiler अनदेखा कर देता है।
✅ Java में 3 प्रकार के comments होते हैं:
प्रकार	प्रारंभ कैसे होता है	कहाँ तक चलता है	उपयोग
Single-line comment	//	उसी लाइन में समाप्त	सामान्य व्याख्या
Multi-line comment	/* से शुरू, */ से खत्म	कई लाइनों में चलता है	बड़े नोट्स के लिए
Documentation comment	/** से शुरू, */ से खत्म	जावा डॉक्यूमेंटेशन टूल (javadoc) में उपयोग	API डॉक्स के लिए
उदाहरण:
// यह एक सिंगल लाइन कमेंट है

/*
 यह एक मल्टी लाइन कमेंट है
 जो कई लाइनों में फैला हो सकता है
*/

/**
 * यह एक डॉक्यूमेंटेशन कमेंट है
 * जो Javadoc द्वारा उपयोग किया जाता है
 */
________________________________________
🔹 3. Data Types (डेटा प्रकार)
Java में डेटा टाइप यह तय करता है कि किसी वेरिएबल में किस प्रकार का डाटा स्टोर होगा।
✅ Data Types के दो प्रकार होते हैं:
प्रकार	उदाहरण	विशेषता
Primitive (मूल)	int, char, boolean, आदि	बिल्ट-इन
Non-Primitive (गैर-मूल)	String, Array, Class, Interface	ऑब्जेक्ट आधारित
________________________________________
🔸 Primitive Data Types (8 प्रकार):
Data Type	Size	मान	उपयोग
byte	1 byte	-128 to 127	memory-efficient
short	2 bytes	-32,768 to 32,767	छोटे नंबर
int	4 bytes	-2B से 2B	डिफ़ॉल्ट इन्टिजर
long	8 bytes	बहुत बड़े नंबर	
float	4 bytes	दशमलव (point values)	वैज्ञानिक कैलकुलेशन
double	8 bytes	उच्च सटीकता	डिफ़ॉल्ट floating-point
char	2 bytes	'a', '1', '$' आदि	सिंगल कैरेक्टर
boolean	1 bit	true / false	लॉजिक के लिए
________________________________________
🔹 4. Variables (चर)
Java में Variable वह नामित स्थान (named memory location) होता है जहाँ डाटा स्टोर होता है।
✅ Variable के प्रकार:
प्रकार	कहाँ उपयोग होता है
Local Variable	किसी मेथड के अंदर
Instance Variable	क्लास लेवल पर (बिना static)
Static Variable	क्लास के लिए shared रहता है
________________________________________
🔸 Variable Declaration और Initialization:
1. Declaration (घोषणा):
int age;      // केवल घोषणा
2. Initialization (मान देना):
age = 25;     // मान देना
या एक साथ दोनों:
int age = 25;
________________________________________
🔸 Valid Declarations के उदाहरण:
int a;
float price;
char grade = 'A';
boolean isActive = true;
________________________________________
✅ निष्कर्ष:
Java प्रोग्रामिंग की शुरुआत में आपको नीचे की चीजें सीखना जरूरी हैं:
विषय	क्यों जरूरी है
Keywords	कोड के संरचना की पहचान करते हैं
Comments	कोड को समझने में आसानी होती है
Data Types	वेरिएबल में कौन सा डेटा होगा, यह तय करते हैं
Variables	डेटा को मेमोरी में स्टोर करने के लिए
🧮 1. Arithmetic Operators (गणितीय ऑपरेटर)
ये ऑपरेटर संख्याओं पर गणितीय क्रियाएं करने के लिए प्रयोग होते हैं।
ऑपरेटर	उपयोग	उदाहरण
+	जोड़	A + B
-	घटाव	A - B
*	गुणा	A * B
/	भाग	A / B
%	शेषफल	A % B
उदाहरण:
int A = 10, B = 20;
System.out.println(A + B); // 30
System.out.println(A - B); // -10
System.out.println(A * B); // 200
System.out.println(A / B); // 0 (इंटीजर डिविज़न)
System.out.println(A % B); // 10 (शेषफल)
________________________________________
🛠️ 2. Assignment Operators (सौंपने वाले ऑपरेटर)
इन ऑपरेटर का उपयोग वेरिएबल लोकेशन में मान देने या बदलने के लिए होता है।
ऑपरेटर	कार्य
=	मूल मान सौंपना
+=	वर्तमान मान में जोड़ कर परिणाम सौंपना
-=	वर्तमान मान में से घटा कर परिणाम सौंपना
*=	गुणा करके परिणाम सौंपना
/=	भाग कर परिणाम सौंपना
%=	शेषफल लेकर सौंपना
उदाहरण:
int x = 5;
x += 3; // x = x + 3 => 8
x *= 2; // x = x * 2 => 16
x /= 4; // x = x / 4 => 4
x %= 3; // x = x % 3 => 1
________________________________________
🔍 3. Relational Operators (तुलनात्मक ऑपरेटर)
इनसे दो मानों के बीच संबंध/तुलना की जाती है और परिणाम boolean (true/false) होता है।
ऑपरेटर	अर्थ
==	बराबर है
!=	बराबर नहीं है
<	छोटा है
>	बड़ा है
<=	छोटा या बराबर है
>=	बड़ा या बराबर है
उदाहरण:
int a = 10, b = 20;
System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a < b);  // true
System.out.println(a >= b); // false
________________________________________
🧠 4. Logical Operators (तार्किक ऑपरेटर)
ये boolean व्यंजनों (expressions) को संयोजित करते हैं।
ऑपरेटर	अर्थ	परिणाम
&&	AND	दोनों true होने पर true
`		`
!	NOT	true को false अथवा false को true में बदलता है
उदाहरण:
boolean p = true, q = false;
System.out.println(p && q); // false
System.out.println(p || q); // true
System.out.println(!p);     // false
________________________________________
🔁 5. Increment / Decrement Operators (इंक्रिमेंट / डीक्रिमेंट)
इनसे वेरिएबल का मान 1 इजाफा या घटाया जाता है।
ऑपरेटर	प्रकार	विवरण
++	इंस्टेंट/प्रोफिक्स	तुरंत वृद्धि
++	पोस्टफिक्स	वृद्धि को बाद में लागू करता है
--	प्रोफिक्स	तुरंत कमी
--	पोस्टफिक्स	कमी को बाद में लागू करता है
उदाहरण:
int count = 5;
count++; // 6 (पोस्ट, बाद में बढेगा)
++count; // 7 (फौरन बढेगा)

int i = 0, j = 0;
int x = i++; // x = 0, फिर i = 1
int y = ++j; // j = 1, फिर y = 1
________________________________________
🧩 6. Unary, Bitwise, Shift, Ternary (अन्य ऑपरेटर)
Java में इन जैसे और भी ऑपरेटर होते हैं:
•	Unary (+, -, !, ~): कांट्रोल बेसिक कार्यों के लिए
•	Bitwise (&, |, ^, ~): bit स्तर पर कार्य
•	Shift (<<, >>, >>>): bits को शिफ्ट करना
•	Ternary (?:): शॉर्ट IF-ELSE
int m = (x > y) ? x : y;
________________________________________
🧮 7. Expressions (व्यंजनों)
Expression = ऑपरेटर + operand का संयोजन
int a = 10,
    b = 20;
int sum = a + b;                    // Arithmetic + assignment
boolean larger = (a > b) && (b > 0); // Relational + logical
int inc = ++a * 2;                  // Increment + arithmetic
________________________________________
📊 8. Complete Java ऑपरेटर Demo कोड
public class OperatorDemo {
    public static void main(String[] args) {
        int num1 = 10, num2 = 20;

        // Arithmetic
        System.out.println("Sum: " + (num1 + num2));
        System.out.println("Diff: " + (num1 - num2));
        System.out.println("Prod: " + (num1 * num2));
        System.out.println("Quotient: " + (num1 / num2));
        System.out.println("Remainder: " + (num1 % num2));

        // Assignment
        int x = 5;
        x += 3;
        System.out.println("x after +=3: " + x);

        // Relational
        System.out.println("Is Equal? " + (num1 == num2));
        System.out.println("Is Less? " + (num1 < num2));

        // Logical
        boolean p = true, q = false;
        System.out.println("AND: " + (p && q));
        System.out.println("OR: " + (p || q));
        System.out.println("NOT: " + (!p));

        // Increment/Decrement
        int count = 5;
        count++;
        System.out.println("After increment: " + count);
        count--;
        System.out.println("After decrement: " + count);
    }
}
________________________________________
🧭 9. निष्कर्ष (Key Takeaways)
1.	Arithmetic: संख्याओं पर गणितीय क्रियाएं
2.	Assignment: मान बदलना
3.	Relational: तुलना कर परिणाम boolean में देना
4.	Logical: boolean expressions जोड़ना
5.	Increment/Decrement: मान को 1 से बदलना
6.	अन्य ऑपरेटर: इंटर्नल/लॉजिक स्तर पर विशेष कार्य
🔤 1. String क्या होता है?
Java में, String एक character (अक्षरों) की श्रृंखला होती है, जैसे "Hello", "World", आदि।
महत्वपूर्ण बात: Java में String immutable होती है, यानी एक बार String बन गई, तो उसे बदला नहीं जा सकता — अगर आप उसमें कुछ जोड़ते हैं, तो वह नया String object बना देता है।
________________________________________
🔧 2. String बनाना (Creating Strings)
🔹 1. String Literal द्वारा
String str1 = "Hello";
यह तरीका String Constant Pool में String को स्टोर करता है।
🔹 2. new कीवर्ड द्वारा
String str2 = new String("Hello");
यह एक नया object Heap में बनाता है।
________________________________________
➕ 3. String Concatenation (जोड़ना)
🔸 + ऑपरेटर का प्रयोग
String first = "Hello";
String second = "World";
String full = first + " " + second;
System.out.println(full); // Hello World
🔸 अन्य data type के साथ जोड़ना
int age = 25;
String result = "My age is " + age;
System.out.println(result); // My age is 25
________________________________________
🧮 4. String के लिए उपयोगी Methods
✔️ length() – String की लंबाई (characters की संख्या)
String s = "Java";
System.out.println(s.length()); // 4
✔️ charAt(index) – किसी index पर character निकालना
System.out.println(s.charAt(1)); // 'a'
✔️ substring(start) और substring(start, end)
System.out.println(s.substring(1)); // "ava"
System.out.println(s.substring(1, 3)); // "av"
✔️ toUpperCase() और toLowerCase()
System.out.println(s.toUpperCase()); // "JAVA"
System.out.println(s.toLowerCase()); // "java"
✔️ indexOf() – कोई अक्षर या शब्द कहाँ है
System.out.println(s.indexOf("v")); // 2
________________________________________
⚖️ 5. String तुलना (Comparison)
🔸 equals() – कंटेंट तुलना (सही तरीका)
String s1 = "Java";
String s2 = "Java";
System.out.println(s1.equals(s2)); // true
🔸 == – reference तुलना (object एक ही है या नहीं)
String s3 = new String("Java");
System.out.println(s1 == s3); // false
________________________________________
🧱 6. StringBuilder और StringBuffer (Mutable Strings)
🔸 StringBuilder – तेज़, लेकिन Thread-safe नहीं
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb); // Hello World
🔸 StringBuffer – धीमा लेकिन Thread-safe
StringBuffer sb = new StringBuffer("Java");
sb.append(" Programming");
System.out.println(sb); // Java Programming
________________________________________
🧵 7. String Formatting (फ़ॉर्मेटिंग)
🔸 String.format() और System.out.printf()
String name = "Pradyumn";
String formatted = String.format("Hello, %s!", name);
System.out.println(formatted); // Hello, Pradyumn!

System.out.printf("Value is %.2f", 45.6789); // Value is 45.68
________________________________________
🔠 8. StringTokenizer – शब्दों को तोड़ना
import java.util.StringTokenizer;

String text = "Hello CTI World";
StringTokenizer st = new StringTokenizer(text);

while(st.hasMoreTokens()) {
    System.out.println(st.nextToken());
}
// Output:
// Hello
// CTI
// World
________________________________________
🔗 9. StringJoiner – String को जोड़ना एक separator के साथ
import java.util.StringJoiner;

StringJoiner joiner = new StringJoiner(", ");
joiner.add("CTI");
joiner.add("World");
System.out.println(joiner); // CTI, World
________________________________________
♻️ 10. Immutable String (Strings बदलते नहीं हैं)
public class Demo {
    public static void main(String[] args) {
        String name = "Sachin";
        name.concat(" Tendulkar");
        System.out.println(name); // Output: Sachin

        name = name.concat(" Tendulkar");
        System.out.println(name); // Output: Sachin Tendulkar
    }
}
________________________________________
📘 11. CharSequence Interface
Java में कई classes CharSequence interface को implement करती हैं:
•	String
•	StringBuilder
•	StringBuffer
•	CharBuffer
ये सभी character sequences को अलग-अलग तरीके से represent करती हैं — कुछ immutable (String), कुछ mutable (Builder, Buffer) होती हैं।
________________________________________
✅ 12. कुछ Commonly Used String Methods
Method	काम
compareTo()	Lexicographical तुलना करता है
replace()	किसी substring को नए से बदलता है
split()	String को टुकड़ों में बाँटना
intern()	String Constant Pool से object लौटाना
________________________________________
🧠 निष्कर्ष (Summary in Hindi)
विषय	विवरण
String Immutable	एक बार बनने के बाद बदली नहीं जा सकती
Concatenation	+ या concat() या StringBuilder
Comparison	equals() से तुलना करें, == से नहीं
Mutable Options	StringBuilder, StringBuffer
Formatting	String.format(), printf()
Tokenizing	StringTokenizer से String को अलग-अलग भागों में बाँटना
📘 Java Input and Output Streams (I/O) – हिंदी में विस्तारपूर्वक समझें
🔶 Java I/O क्या है?
Java में I/O (Input and Output) का मतलब है –
📥 Input (इनपुट): डेटा को बाहर से Java प्रोग्राम में लाना (जैसे कीबोर्ड से पढ़ना)
📤 Output (आउटपुट): डेटा को Java प्रोग्राम से बाहर भेजना (जैसे स्क्रीन पर दिखाना)
Java में I/O को आसान और शक्तिशाली बनाने के लिए Stream (धारा) नामक अवधारणा का उपयोग किया जाता है।
________________________________________
🚰 Stream क्या है?
Stream एक डेटा की निरंतर धारा है — जैसे नल से पानी बहता है, वैसे ही डेटा stream के रूप में Java प्रोग्राम में आता या बाहर जाता है।
Java में दो प्रकार की streams होती हैं:
Stream Type	काम
Input Stream	डेटा को प्रोग्राम के अंदर लाने के लिए (Input)
Output Stream	डेटा को प्रोग्राम के बाहर भेजने के लिए (Output)
________________________________________
🛠️ Java में पहले से बनी तीन Standard Streams
Stream	काम
System.in	कीबोर्ड से डेटा लेने के लिए (Input stream)
System.out	स्क्रीन पर डेटा दिखाने के लिए (Output stream)
System.err	एरर दिखाने के लिए (Error stream)
________________________________________
📤 Java Output Methods (स्क्रीन पर प्रिंट करने के तरीके)
✅ 1. System.out.print()
👉 टेक्स्ट को एक ही लाइन में दिखाता है, अगली प्रिंटिंग उसी लाइन से शुरू होती है।
System.out.print("Hello ");
System.out.print("World!");
Output:
Hello World!
________________________________________
✅ 2. System.out.println()
👉 टेक्स्ट को दिखाकर कर्सर को अगली लाइन में ले जाता है।
System.out.println("Line 1");
System.out.println("Line 2");
Output:
Line 1  
Line 2
________________________________________
✅ 3. System.out.printf()
👉 आउटपुट को फॉर्मेट (सजाकर) दिखाने के लिए।
String name = "Anshu";
int age = 24;
double salary = 50000.75;

System.out.printf("Name: %s%n", name);
System.out.printf("Age: %d%n", age);
System.out.printf("Salary: ₹%.2f%n", salary);
Output:
Name: Anshu  
Age: 24  
Salary: ₹50000.75
Format Code	मतलब
%s	String
%d	Integer
%.2f	Float दो दशमलव तक
%n	नया लाइन प्लेटफॉर्म के अनुसार
________________________________________
📥 Java Input: कीबोर्ड से डेटा लेना (System.in)
Java में System.in से डेटा लेने के लिए हम Scanner या BufferedReader का उपयोग करते हैं।
🔹 Scanner का प्रयोग:
import java.util.Scanner;

public class InputExample {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    System.out.print("अपना नाम दर्ज करें: ");
    String name = sc.nextLine();

    System.out.print("उम्र दर्ज करें: ");
    int age = sc.nextInt();

    System.out.println("नमस्ते " + name + ", आपकी उम्र है " + age + " साल");
  }
}
________________________________________
📁 File Handling – फ़ाइल से पढ़ना और लिखना
Java में फ़ाइल से डेटा पढ़ने और लिखने के लिए InputStream और OutputStream क्लासेस का प्रयोग होता है।
________________________________________
📥 1. InputStream Classes (डेटा पढ़ना)
Class Name	काम
FileInputStream	फ़ाइल से byte में डेटा पढ़ना
BufferedInputStream	डेटा को बफर में पढ़ना (efficient)
ByteArrayInputStream	byte array से डेटा पढ़ना
🔹 File से पढ़ने का उदाहरण:
import java.io.*;

public class ReadFile {
  public static void main(String[] args) throws IOException {
    FileInputStream fin = new FileInputStream("test.txt");
    int i;
    while((i = fin.read()) != -1){
      System.out.print((char)i);
    }
    fin.close();
  }
}
________________________________________
📤 2. OutputStream Classes (डेटा लिखना)
Class Name	काम
FileOutputStream	फ़ाइल में byte लिखना
BufferedOutputStream	डेटा को बफर में लिखना
ByteArrayOutputStream	byte array में डेटा लिखना
🔹 File में लिखने का उदाहरण:
import java.io.*;

public class WriteFile {
  public static void main(String[] args) throws IOException {
    FileOutputStream fout = new FileOutputStream("test.txt");
    String str = "CTI World - Java I/O Example";
    byte b[] = str.getBytes();
    fout.write(b);
    fout.close();
    System.out.println("डेटा सफलतापूर्वक लिखा गया।");
  }
}
________________________________________
🔄 Java Streams Summary – एक नज़र में
Stream	Description	Example Classes
InputStream	Input bytes पढ़ने के लिए	FileInputStream, BufferedInputStream
OutputStream	Output bytes लिखने के लिए	FileOutputStream, BufferedOutputStream
Reader	Character input	FileReader, BufferedReader
Writer	Character output	FileWriter, BufferedWriter
________________________________________
✅ निष्कर्ष (Conclusion)
•	Java I/O में Stream का उपयोग input/output को आसान और संगठित करने के लिए होता है।
•	System.in, System.out, और System.err Java के तीन मुख्य predefined stream हैं।
•	फ़ाइल से पढ़ने और लिखने के लिए InputStream और OutputStream subclasses का उपयोग होता है।
•	Formatted output के लिए printf() बहुत उपयोगी है।
📥 Java Input Using Scanner & Console Class – हिंदी में विस्तारपूर्वक
Java में यूज़र से इनपुट लेने के दो सामान्य तरीके हैं:
1.	Scanner क्लास का उपयोग करके
2.	Console क्लास का उपयोग करके
________________________________________
🧾 1. Scanner Class से Input लेना
📌 Scanner Class क्या है?
Scanner एक predefined क्लास है जो java.util पैकेज में पाई जाती है। इसका उपयोग यूज़र से विभिन्न प्रकार के डेटा (int, float, String, आदि) लेने के लिए किया जाता है।
🔧 Syntax:
import java.util.Scanner;
Scanner sc = new Scanner(System.in);
________________________________________
✅ Scanner Class की Methods:
Method	काम
nextInt()	int इनपुट पढ़ता है
nextDouble()	double पढ़ता है
nextLine()	पूरी लाइन (String) पढ़ता है
next()	एक शब्द (token) पढ़ता है
next().charAt(0)	एक कैरेक्टर पढ़ता है
hasNextInt()	चेक करता है कि अगला int है या नहीं
________________________________________
🔹 Example: सभी प्रकार के डेटा इनपुट करना
import java.util.Scanner;

public class ScannerDemo1 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // String input (पूरा नाम)
        System.out.print("नाम दर्ज करें: ");
        String name = sc.nextLine();

        // Character input
        System.out.print("लिंग (M/F) दर्ज करें: ");
        char gender = sc.next().charAt(0);

        // Integer input
        System.out.print("उम्र दर्ज करें: ");
        int age = sc.nextInt();

        // Double input
        System.out.print("CGPA दर्ज करें: ");
        double cgpa = sc.nextDouble();

        // आउटपुट
        System.out.println("Name: " + name);
        System.out.println("Gender: " + gender);
        System.out.println("Age: " + age);
        System.out.println("CGPA: " + cgpa);
        
        sc.close(); // Scanner बंद करना जरूरी है
    }
}
🔸 Input:
AKASH MOHAN
M
24
91.0
🔸 Output:
Name: AKASH MOHAN
Gender: M
Age: 24
CGPA: 91.0
________________________________________
🔹 Example: कई Int इनपुट लेना और Mean (औसत) निकालना
import java.util.Scanner;

public class ScannerDemo2 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int sum = 0, count = 0;

        System.out.println("संख्याएँ दर्ज करें (Ctrl + Z से बंद करें):");

        while (sc.hasNextInt()) {
            int num = sc.nextInt();
            sum += num;
            count++;
        }

        if (count > 0) {
            int mean = sum / count;
            System.out.println("Mean: " + mean);
        } else {
            System.out.println("कोई संख्या नहीं दी गई।");
        }

        sc.close();
    }
}
📝 यह कोड तब तक नंबर पढ़ता है जब तक आप EOF (Ctrl + Z / Ctrl + D) नहीं दबाते।
________________________________________
🔒 Scanner के कुछ Important Points:
पॉइंट	विवरण
📌 next()	एक शब्द पढ़ता है
📌 nextLine()	पूरी लाइन पढ़ता है
📌 hasNextInt()	अगला int है या नहीं यह चेक करता है
📌 close()	Scanner बंद करना जरूरी है
📌 useDelimiter()	Delimiter को बदलने के लिए
❌ Thread Safe नहीं है	एक साथ कई थ्रेड्स से प्रयोग न करें
❗ Exception Handling	गलत इनपुट से बचने के लिए try-catch जरूरी
________________________________________
🧾 2. Console Class से Input लेना
📌 Console Class क्या है?
Console क्लास भी यूज़र से इनपुट लेने के लिए काम आती है, लेकिन यह मुख्यतः सिक्योर इनपुट (जैसे पासवर्ड) के लिए बेहतर मानी जाती है।
📍 यह क्लास java.io.Console पैकेज में होती है।
________________________________________
🔧 Syntax:
Console c = System.console();
String name = c.readLine("नाम दर्ज करें: ");
🔐 Secure Input (जैसे Password):
char[] password = c.readPassword("पासवर्ड दर्ज करें: ");
________________________________________
🔹 Example: Console Class से इनपुट लेना
import java.io.Console;

public class ConsoleInput {
    public static void main(String[] args) {
        Console c = System.console();

        if (c == null) {
            System.out.println("Console उपलब्ध नहीं है। IDE में try करें CMD में।");
            return;
        }

        String name = c.readLine("अपना नाम दर्ज करें: ");
        char[] password = c.readPassword("पासवर्ड दर्ज करें: ");

        System.out.println("नमस्ते, " + name);
        System.out.println("पासवर्ड लंबाई: " + password.length);
    }
}
🔸 Note: Console class कुछ IDEs (जैसे IntelliJ, Eclipse) में काम नहीं करती। इसे Command Prompt / Terminal में चलाएं।
________________________________________
🔍 Scanner vs Console – तुलना
Feature	Scanner	Console
Input Types	सभी Primitive और String	String और Password
IDE Support	Supported	Mostly Unsupported
Password Input	❌ Not secure	✅ Secure
Methods	next(), nextLine(), etc.	readLine(), readPassword()
Use Case	General input	Command-line secure input
________________________________________
📌 निष्कर्ष (Conclusion)
•	✅ Scanner क्लास सरल है और लगभग हर तरह के इनपुट के लिए उपयुक्त है।
•	✅ Console क्लास सिक्योर इनपुट जैसे पासवर्ड के लिए बेहतर है लेकिन IDEs में काम नहीं करती।
•	⚠️ Exception Handling और Input Validation ज़रूरी है ताकि इनपुट गलत होने पर प्रोग्राम क्रैश न हो।
Java में Control Statements (नियंत्रण कथन)
Java Compiler कोड को ऊपर से नीचे की दिशा में पढ़ता और चलाता है। यानी कोड की पंक्तियाँ उसी क्रम में चलती हैं जैसे वे लिखी गई होती हैं।
लेकिन Java में कुछ विशेष प्रकार के statements (नियंत्रण कथन) दिए गए हैं जिनसे हम कोड की प्रवाह दिशा (flow) को नियंत्रित कर सकते हैं। ऐसे statements को Control Flow Statements कहते हैं।
यह Java की एक बहुत ही मूलभूत विशेषता है, जो प्रोग्राम को एक लॉजिकल और स्मूद फ्लो में चलाने में मदद करती है।
________________________________________
Java में Control Statements के तीन मुख्य प्रकार होते हैं:
1. Decision-Making Statements (निर्णय लेने वाले कथन)
•	if statement
•	switch statement
2. Loop Statements (लूप या पुनरावृत्ति वाले कथन)
•	do-while loop
•	while loop
•	for loop
•	for-each loop
3. Jump Statements (जंप या छलांग लगाने वाले कथन)
•	break
•	continue
________________________________________
🧠 1. Decision-Making Statements (निर्णय लेने वाले कथन)
यह statements किसी शर्त (condition) की जांच करते हैं और उसी आधार पर निर्णय लेते हैं कि कौन सा कोड ब्लॉक चलेगा।
Java में दो प्रकार के निर्णय लेने वाले statements हैं:
•	if statement
•	switch statement
________________________________________
🔷 If Statement (यदि कथन)
Java में if का प्रयोग किसी Boolean condition (true/false) की जांच के लिए किया जाता है। यदि condition true होती है, तो कोड ब्लॉक चलेगा।
Java में if के चार प्रकार होते हैं:
1. ✅ Simple if Statement
यह सबसे साधारण if statement है। यदि condition true है, तो ही अंदर का code चलेगा।
if(condition) {
    // यह कोड तब ही चलेगा जब condition true होगी
}
उदाहरण:
public class Student {
    public static void main(String[] args) {
        int x = 10;
        int y = 12;
        if(x + y > 20) {
            System.out.println("x + y is greater than 20");
        }
    }
}
आउटपुट:
x + y is greater than 20
________________________________________
2. ✅ if-else Statement
अगर condition true है, तो if block चलेगा, अन्यथा else block चलेगा।
if(condition) {
    // Condition true होने पर चलेगा
} else {
    // Condition false होने पर चलेगा
}
उदाहरण:
public class Student {
    public static void main(String[] args) {
        int x = 10;
        int y = 12;
        if(x + y < 10) {
            System.out.println("x + y is less than 10");
        } else {
            System.out.println("x + y is greater than 20");
        }
    }
}
आउटपुट:
x + y is greater than 20
________________________________________
3. ✅ if-else-if Ladder
यह एक condition की श्रृंखला (chain) होती है। एक condition false होने पर अगली condition चेक की जाती है।
if(condition1) {
    // condition1 true होने पर
} else if(condition2) {
    // condition2 true होने पर
} else {
    // सभी conditions false होने पर
}
उदाहरण:
public class Student {
    public static void main(String[] args) {
        String city = "Delhi";
        if(city.equals("Meerut")) {
            System.out.println("City is Meerut");
        } else if(city.equals("Noida")) {
            System.out.println("City is Noida");
        } else if(city.equals("Agra")) {
            System.out.println("City is Agra");
        } else {
            System.out.println(city);
        }
    }
}
आउटपुट:
Delhi
________________________________________
4. ✅ Nested if Statement
एक if के अंदर दूसरा if भी हो सकता है। इसे Nested if कहते हैं।
if(condition1) {
    if(condition2) {
        // condition1 और condition2 दोनों true होने पर
    } else {
        // condition1 true और condition2 false होने पर
    }
}
उदाहरण:
public class Student {
    public static void main(String[] args) {
        String address = "Delhi, India";
        if(address.endsWith("India")) {
            if(address.contains("Meerut")) {
                System.out.println("Your city is Meerut");
            } else if(address.contains("Noida")) {
                System.out.println("Your city is Noida");
            } else {
                System.out.println(address.split(",")[0]);
            }
        } else {
            System.out.println("You are not living in India");
        }
    }
}
आउटपुट:
Delhi
________________________________________
🔷 Switch Statement (स्विच कथन)
switch statement एक प्रकार का decision-making टूल है जो एक expression के multiple संभावित values के आधार पर एक विशेष block को execute करता है।
यह if-else-if के बजाय प्रयोग किया जा सकता है, जिससे कोड अधिक साफ़ और पढ़ने योग्य बनता है।
switch(expression) {
    case value1:
        // statement1
        break;
    case value2:
        // statement2
        break;
    ...
    default:
        // यदि कोई case match न हो
}
📌 नियम:
•	switch में expression केवल int, byte, short, char, enum और Java 7 से String हो सकता है।
•	case values constant और unique होनी चाहिए।
•	break keyword जरूरी नहीं, लेकिन इसका प्रयोग अगले cases को रोकने के लिए होता है।
उदाहरण:
public class Student {
    public static void main(String[] args) {
        int num = 2;
        switch (num) {
            case 0:
                System.out.println("number is 0");
                break;
            case 1:
                System.out.println("number is 1");
                break;
            default:
                System.out.println(num);
        }
    }
}
आउटपुट:
2
________________________________________
✅ निष्कर्ष (Conclusion)
Java में Control Flow Statements प्रोग्राम की लॉजिक को तय करने और उस पर नियंत्रण रखने के लिए बहुत महत्वपूर्ण हैं। इनके मुख्य प्रकार हैं:
प्रकार	विवरण
Decision-making	if, if-else, switch जैसे statements से decision लिए जाते हैं
Looping	for, while, do-while, for-each से कोड को बार-बार चलाया जाता है
Jumping	break, continue से कोड के flow को control किया जाता है
🔁 Java Loop Statements (लूप स्टेटमेंट्स)
कभी-कभी प्रोग्रामिंग में हमें कोई एक कोड का हिस्सा तब तक बार-बार चलाना पड़ता है जब तक कोई विशेष शर्त (condition) सही बनी रहे।
ऐसी स्थिति में loop statements का उपयोग किया जाता है, जिससे कोड के एक हिस्से को कई बार चलाया जा सकता है।
Java में निम्नलिखित तीन प्रकार के loops होते हैं:
✅ 1. for loop
✅ 2. while loop
✅ 3. do-while loop
________________________________________
🔷 1. for Loop (फॉर लूप)
Java में for loop, C और C++ के समान है। इसका उपयोग तब किया जाता है जब हमें पहले से पता हो कि कितनी बार हमें loop चलाना है।
🧾 Syntax (संरचना):
for(initialization; condition; increment/decrement) {
    // statements to execute repeatedly
}
🔁 Flow Chart (प्रवाह चार्ट):
Start → Initialization → Condition Check
          ↓        ↑
      Statements → Increment/Decrement
          ↓
      (Condition false → Exit)
📘 उदाहरण:
public class Calculation {
    public static void main(String[] args) {
        int sum = 0;
        for(int j = 1; j <= 10; j++) {
            sum = sum + j;
        }
        System.out.println("The sum of first 10 natural numbers is " + sum);
    }
}
आउटपुट:
The sum of first 10 natural numbers is 55
________________________________________
🔷 2. for-each Loop (फॉर-ईच लूप)
यह Java का Enhanced for loop है। इसका प्रयोग मुख्यतः array या collections को ट्रैवर्स (iterate) करने के लिए किया जाता है।
🧾 Syntax:
for(data_type var : array_or_collection) {
    // statements
}
📘 उदाहरण:
public class Calculation {
    public static void main(String[] args) {
        String[] names = {"Java", "C", "C++", "Python", "JavaScript"};
        System.out.println("Printing the content of the array names:\n");
        for(String name : names) {
            System.out.println(name);
        }
    }
}
आउटपुट:
Java
C
C++
Python
JavaScript
________________________________________
🔷 3. while Loop (व्हाइल लूप)
जब आपको पहले से यह नहीं पता हो कि loop कितनी बार चलेगा, तब while loop का प्रयोग किया जाता है। यह एक entry-controlled loop है।
🧾 Syntax:
while(condition) {
    // looping statements
}
🔁 Flow Chart:
Start → Condition Check
          ↓
        TRUE → Statements → Repeat
        FALSE → Exit
📘 उदाहरण:
public class Calculation {
    public static void main(String[] args) {
        int i = 0;
        System.out.println("Printing the list of first 10 even numbers:");
        while(i <= 10) {
            System.out.println(i);
            i = i + 2;
        }
    }
}
आउटपुट:
0
2
4
6
8
10
________________________________________
🔷 4. do-while Loop (डू-व्हाइल लूप)
यह एक exit-controlled loop है। यानी यह पहले कोड को चलाता है, फिर condition चेक करता है। यह loop कम से कम एक बार तो चलेगा ही, चाहे condition false हो।
🧾 Syntax:
do {
    // statements
} while(condition);
🔁 Flow Chart:
Start → Statements → Condition Check
          ↓             ↑
        FALSE         TRUE
          ↓             |
        Exit        Repeat
📘 उदाहरण:
public class Calculation {
    public static void main(String[] args) {
        int i = 0;
        System.out.println("Printing the list of first 10 even numbers:");
        do {
            System.out.println(i);
            i = i + 2;
        } while(i <= 10);
    }
}
आउटपुट:
0
2
4
6
8
10
________________________________________
🔁 Jump Statements in Java (जंप स्टेटमेंट्स)
Jump statements प्रोग्राम के flow को control करते हैं, यानी ये प्रोग्राम को एक जगह से दूसरी जगह jump करा सकते हैं।
Java में दो मुख्य jump statements होते हैं:
✅ 1. break
✅ 2. continue
________________________________________
🔸 1. break Statement (ब्रेक स्टेटमेंट)
break का उपयोग किसी loop या switch को तुरंत रोकने के लिए किया जाता है।
यह केवल loop या switch के अंदर ही लिखा जा सकता है।
📘 उदाहरण:
public class BreakExample {
    public static void main(String[] args) {
        for(int i = 0; i <= 10; i++) {
            if(i == 6) {
                break;
            }
            System.out.println(i);
        }
    }
}
आउटपुट:
0
1
2
3
4
5
________________________________________
🔸 2. continue Statement (कंटिन्यू स्टेटमेंट)
continue का उपयोग loop के एक iteration को skip करने के लिए किया जाता है। यह current iteration को छोड़ कर loop को अगले round पर ले जाता है।
📘 उदाहरण:
public class ContinueExample {
    public static void main(String[] args) {
        for(int i = 0; i <= 2; i++) {
            for(int j = i; j <= 5; j++) {
                if(j == 4) {
                    continue;
                }
                System.out.println(j);
            }
        }
    }
}
आउटपुट:
0
1
2
3
5
1
2
3
5
2
3
5
________________________________________
🧠 निष्कर्ष (Conclusion)
प्रकार	उद्देश्य
for loop	जब iterations की संख्या ज्ञात हो
while loop	जब iterations की संख्या अज्ञात हो और condition पहले चेक हो
do-while loop	कम से कम एक बार कोड चलाना हो और बाद में condition चेक हो
break	loop या switch को बीच में रोकना
continue	किसी विशेष iteration को छोड़कर अगले पर जाना
🛑 Java में प्रोग्राम को कैसे Terminate करें (समाप्त करें)
🔹 System.exit() Method क्या है?
Java में System.exit() method का उपयोग प्रोग्राम को किसी भी बिंदु पर अचानक समाप्त करने के लिए किया जाता है। यह method JVM (Java Virtual Machine) को ही terminate कर देता है, जिससे पूरा प्रोग्राम रुक जाता है।
यह method java.lang.System क्लास का हिस्सा है।
________________________________________
🧾 Syntax (संरचना):
public static void exit(int status);
🔸 Parameter (पैरामीटर):
•	यह method एक integer status code लेता है:
o	exit(0) – सफल termination (success)
o	exit(1) या exit(-1) – असफल termination (failure या exception)
नोट: 0 के अलावा कोई भी value प्रोग्राम के असफल रूप से terminate होने को दर्शाती है।
________________________________________
✅ System.exit() कब उपयोग करें?
1.	जब कोई असामान्य परिस्थिति आ जाए।
2.	जब आप exception के बजाय सीधे termination दिखाना चाहते हैं।
3.	गलत input मिलने पर प्रोग्राम को तुरंत बंद करना हो।
________________________________________
📘 उदाहरण 1 – System.exit() का सिंपल उपयोग
public class SampleExitMethod {
    public static void exampleMethod(int[] array1) {
        for (int i = 0; i < array1.length; i++) {
            if (i > 4) {
                System.out.println("Terminating JVM...");
                System.exit(0);
            }
            System.out.println("Array Index: " + i + " Array Element: " + array1[i]);
        }
    }

    public static void main(String[] args) {
        int[] array1 = {0, 2, 4, 6, 8, 10, 12, 14, 16};
        exampleMethod(array1);
    }
}
🖨️ Output:
Array Index: 0 Array Element: 0  
Array Index: 1 Array Element: 2  
Array Index: 2 Array Element: 4  
Array Index: 3 Array Element: 6  
Array Index: 4 Array Element: 8  
Terminating JVM...
________________________________________
📘 उदाहरण 2 – try-catch-finally में System.exit()
import java.io.*;

public class Check {
    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader("file.txt"));
            System.out.println(br.readLine());
            br.close();
        } catch (IOException e) {
            System.out.println("Exception caught. Terminating JVM.");
            System.exit(0);
        } finally {
            System.out.println("Exiting the program");
        }
    }
}
🖨️ Output:
Exception caught. Terminating JVM.
🛑 Explanation:
•	यहाँ file.txt file मौजूद नहीं है, इसलिए IOException आएगा।
•	catch block में System.exit(0) लिखा गया है जो JVM को terminate कर देता है।
•	इसलिए finally block कभी execute नहीं होता, क्योंकि JVM पहले ही terminate हो चुका होता है।
________________________________________
🟡 Java में return keyword से method को exit करना
Java में return keyword का उपयोग method से बाहर निकलने के लिए किया जाता है। यदि method void है, तब return; से आप सिर्फ execution रोक सकते हैं।
📘 उदाहरण:
public class SampleExitMethod2 {
    public static void SubMethod(int num1, int num2) {
        if (num2 > num1)
            return;  // method से बाहर निकल जाए
        int answer = num1 - num2;
        System.out.println(answer);
    }

    public static void main(String[] args) {
        SubMethod(2, 5);     // return हो जाएगा, कोई output नहीं
        SubMethod(10, 3);    // output: 7
        SubMethod(100, 50);  // output: 50
        SubMethod(102, 110); // return हो जाएगा, कोई output नहीं
    }
}
🖨️ Output:
7
50
________________________________________
🚫 क्या Java में goto होता है?
नहीं, Java में goto keyword मौजूद नहीं है। हालांकि, यह एक reserved keyword है, लेकिन इसका प्रयोग नहीं किया जाता।
Goto क्यों नहीं है Java में?
1.	इससे प्रोग्राम को समझना कठिन होता है।
2.	कोड का maintain करना मुश्किल हो जाता है।
3.	Compiler optimization को रोकता है।
________________________________________
✅ Labels का उपयोग break/continue के साथ किया जा सकता है
Java में goto का कार्य हम labels के साथ कर सकते हैं, खासकर nested loops में।
📘 उदाहरण – labeled break:
public class Main {
    public static void main(String[] args) {
        first: {
            second: {
                third: {
                    System.out.println("Before the break statement");
                    if (true)
                        break second;
                    System.out.println("This line won't execute");
                }
                System.out.println("Inside second block");
            }
            System.out.println("Part of first block, outside second block.");
        }
    }
}
🖨️ Output:
Before the break statement  
Part of first block, outside second block.
________________________________________
🔚 निष्कर्ष (Conclusion)
तरीका	उद्देश्य
System.exit(0)	JVM को terminate करता है (पूरे प्रोग्राम को तुरंत रोक देता है)
System.exit(1/-1)	unsuccessful termination दर्शाता है
return keyword	केवल एक method से exit करने के लिए
goto keyword	Java में उपलब्ध नहीं है, केवल reserved है
Labels + break	goto के जैसा behavior achieve करने के लिए
📌 Java Numbers (संख्याएँ)
Java में संख्याएँ दो प्रकार की होती हैं:
🔹 1. Integer Types (पूर्णांक प्रकार)
•	ये पूर्ण संख्या (whole numbers) को दर्शाते हैं — जैसे: 123, -456
•	इनमें कोई दशमलव नहीं होता
•	Java में निम्न प्रकार के integer types होते हैं:
o	byte
o	short
o	int
o	long
➤ Byte
•	सीमा (range): -128 से 127 तक
•	Memory की बचत के लिए उपयोग करें जब आपको पता हो कि मान इसी सीमा में रहेगा।
byte myNum = 100;
System.out.println(myNum);  // Output: 100
➤ Short
•	सीमा: -32,768 से 32,767 तक
short myNum = 5000;
System.out.println(myNum);  // Output: 5000
➤ Int (सबसे अधिक उपयोग होने वाला)
•	सीमा: -2,147,483,648 से 2,147,483,647
•	सामान्यतः किसी संख्या को स्टोर करने के लिए int सबसे उपयुक्त होता है।
int myNum = 100000;
System.out.println(myNum);  // Output: 100000
➤ Long
•	बहुत बड़ी संख्या को स्टोर करने के लिए
•	सीमा: -9,223,372,036,854,775,808 से 9,223,372,036,854,775,807
•	ध्यान दें: मान के अंत में 'L' लगाना जरूरी है
long myNum = 15000000000L;
System.out.println(myNum);  // Output: 15000000000
________________________________________
🔹 2. Floating Point Types (दशमलव वाले प्रकार)
•	जब दशमलव संख्या (decimal/fractional number) की आवश्यकता हो — जैसे 3.14, 9.99
•	दो प्रकार:
o	float → 32-bit
o	double → 64-bit (ज़्यादा प्रिसिजन)
➤ Float
float myNum = 5.75f;
System.out.println(myNum);  // Output: 5.75
➤ Double
double myNum = 19.99d;
System.out.println(myNum);  // Output: 19.99
⚠️ float के लिए ‘f’ और double के लिए ‘d’ लगाना जरूरी होता है (optional for double but good practice)
________________________________________
📌 Java Strings (स्ट्रिंग्स)
Java में, String एक ऑब्जेक्ट होता है जो characters की श्रृंखला (sequence) को represent करता है।
🔹 String को बनाने के दो तरीके होते हैं:
1.	By String Literal
2.	By new keyword
________________________________________
🔸 1. String Literal
जब आप double quotes " के अंदर string लिखते हैं:
String s = "Welcome";
➡ Java इस string को String Constant Pool में स्टोर करता है। यदि वही string पहले से मौजूद हो, तो नया object नहीं बनता — इससे memory की बचत होती है।
________________________________________
🔸 2. By new Keyword
यह तरीका हमेशा heap memory में एक नया object बनाएगा:
String s = new String("Welcome");
➡ इसमें दो objects बनते हैं — एक heap में और एक pool में।
________________________________________
🔹 Java String के कुछ लोकप्रिय Methods
•	length() – स्ट्रिंग की लंबाई
•	charAt(index) – किसी इंडेक्स का कैरेक्टर
•	equals() – दो strings की तुलना
•	concat() – दो strings को जोड़ना
•	substring() – किसी हिस्से को निकालना
•	replace() – किसी कैरेक्टर को बदलना
________________________________________
📘 Java String का उदाहरण:
public class StringExample {
    public static void main(String[] args) {
        String s1 = "java"; // String literal
        char ch[] = {'s', 't', 'r', 'i', 'n', 'g'};
        String s2 = new String(ch); // char array से string
        String s3 = new String("example"); // new keyword से

        System.out.println(s1); // Output: java
        System.out.println(s2); // Output: string
        System.out.println(s3); // Output: example
    }
}
________________________________________
📝 निष्कर्ष (Conclusion)
विषय	जानकारी
Integer Types	byte, short, int, long (पूर्णांक)
Floating Types	float, double (दशमलव वाले)
String क्या है?	Characters की श्रृंखला (Object form में)
String बनाने के तरीके	String literal और new keyword
Memory Management	Literal memory efficient होता है
String के methods	compare, concat, equals, replace, length आदि
📘 Java Arrays (जावा ऐरे)
🔹 Array क्या होता है?
•	Array एक डेटा स्ट्रक्चर है जिसमें एक जैसे डेटा टाइप के multiple values को स्टोर किया जाता है।
•	Java में array ऑब्जेक्ट होता है जो elements को continuous memory location में स्टोर करता है।
•	Index-based होता है: पहला एलिमेंट a[0] पर, दूसरा a[1] पर और ऐसे ही।
________________________________________
📌 Java Array की विशेषताएँ
विशेषता	विवरण
Fixed Size	एक बार साइज तय होने पर इसे बदला नहीं जा सकता
Index Based	प्रत्येक एलिमेंट का एक index होता है (0 से शुरू)
Homogeneous Elements	केवल एक ही प्रकार के डेटा को स्टोर करता है
Random Access	किसी भी index का डेटा सीधे access किया जा सकता है
________________________________________
🔹 Java में Array कैसे बनाएं?
1️⃣ Array Declaration (घोषणा):
int[] arr;      // preferred way
int arr[];      // valid
2️⃣ Array Instantiation (बनाना):
arr = new int[5];  // 5 integer values के लिए जगह बनती है
3️⃣ Array Initialization (मान भरना):
arr[0] = 10;
arr[1] = 20;
...
✅ एक लाइन में सब कुछ:
int[] arr = {10, 20, 30, 40, 50};
________________________________________
🔹 Array को Print करने के तरीके
1️⃣ For Loop के साथ:
for(int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
2️⃣ For-Each Loop के साथ:
for(int num : arr) {
    System.out.println(num);
}
________________________________________
🔹 Array को Method में पास करना
class Example {
    static void printMin(int[] arr) {
        int min = arr[0];
        for(int i = 1; i < arr.length; i++) {
            if(arr[i] < min) min = arr[i];
        }
        System.out.println("Minimum: " + min);
    }

    public static void main(String[] args) {
        int[] numbers = {33, 3, 4, 5};
        printMin(numbers);
    }
}
🟢 Output:
Minimum: 3
________________________________________
🧮 Multidimensional Arrays (बहु-आयामी ऐरे)
➤ 2D Array – Row × Column
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
🔹 2D Array Print करने का तरीका:
for(int i = 0; i < 3; i++) {
    for(int j = 0; j < 3; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
________________________________________
✅ Matrix Addition (दो मैट्रिक्स का जोड़)
int[][] a = {{1, 2, 3}, {4, 5, 6}};
int[][] b = {{1, 1, 1}, {1, 1, 1}};
int[][] sum = new int[2][3];

for(int i = 0; i < 2; i++) {
    for(int j = 0; j < 3; j++) {
        sum[i][j] = a[i][j] + b[i][j];
        System.out.print(sum[i][j] + " ");
    }
    System.out.println();
}
🟢 Output:
2 3 4
5 6 7
________________________________________
✅ Matrix Multiplication (दो मैट्रिक्स का गुणा)
int[][] a = {{1,1,1}, {2,2,2}, {3,3,3}};
int[][] b = {{1,1,1}, {2,2,2}, {3,3,3}};
int[][] result = new int[3][3];

for(int i = 0; i < 3; i++) {
    for(int j = 0; j < 3; j++) {
        result[i][j] = 0;
        for(int k = 0; k < 3; k++) {
            result[i][j] += a[i][k] * b[k][j];
        }
        System.out.print(result[i][j] + " ");
    }
    System.out.println();
}
🟢 Output:
6 6 6
12 12 12
18 18 18
________________________________________
✅ Java Arrays: निष्कर्ष (Conclusion)
पॉइंट	विवरण
Array क्या है?	समान प्रकार के डेटा को स्टोर करने का object
Types	Single Dimensional, Multidimensional
Access	Index द्वारा
Printing	For loop या for-each loop से
Methods में Pass	हाँ, arrays को method में भेजा जा सकता है
सीमा	Fixed size (ArrayList में dynamic size होता है)
Memory	Continuous location में allocate होती है
📘 Java Classes और Objects (कक्षा और ऑब्जेक्ट)
🔹 Java क्या है?
Java एक object-oriented programming भाषा है। इसका मतलब है कि Java में सब कुछ objects और classes से संबंधित होता है।
________________________________________
✅ Class क्या होती है?
•	Class एक ब्लूप्रिंट (Blueprint) होती है जिसके आधार पर objects बनाए जाते हैं।
•	इसमें attributes (variables) और methods (functions) होते हैं।
🧾 उदाहरण:
एक Car class बना सकते हैं जिसमें:
•	Attributes: color, model, speed
•	Methods: drive(), brake()
________________________________________
✅ Object क्या होता है?
•	Object एक real-world entity है जिसे किसी class से बनाया जाता है।
•	Object में properties और behaviors होते हैं।
🧾 उदाहरण:
Car एक class है →
myCar, yourCar अलग-अलग objects हैं, जिनके color या speed अलग हो सकते हैं।
________________________________________
🛠️ Java में Class बनाना
public class Main {
    int x = 5;  // attribute
}
________________________________________
🛠️ Object कैसे बनाएं?
public class Main {
    int x = 5;

    public static void main(String[] args) {
        Main myObj = new Main();  // Object creation
        System.out.println(myObj.x);  // Output: 5
    }
}
🟢 Output:
5
________________________________________
🔁 Java Methods (विधियाँ)
🔹 Method क्या होती है?
•	Method एक block of code होता है जो तब चलता है जब उसे call किया जाता है।
•	इसका प्रयोग code reuse के लिए होता है।
📌 Method Declaration Syntax:
static void myMethod() {
    // code to execute
}
•	static: इसे बिना object बनाए call कर सकते हैं
•	void: method कुछ return नहीं करता
________________________________________
▶️ Method को कैसे Call करें?
public class Main {
    static void myMethod() {
        System.out.println("I just got executed!");
    }

    public static void main(String[] args) {
        myMethod();  // Calling the method
    }
}
🟢 Output:
I just got executed!
________________________________________
📥 Method with Parameters (Parameters के साथ Method)
public class Main {
    static void greetUser(String name) {
        System.out.println("Hello, " + name);
    }

    public static void main(String[] args) {
        greetUser("Amit");
        greetUser("Riya");
    }
}
🟢 Output:
Hello, Amit  
Hello, Riya
________________________________________
🔄 Return Value वाली Method
public class Main {
    static int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int result = add(5, 3);
        System.out.println(result);  // Output: 8
    }
}
________________________________________
📚 Java Classes vs Objects: Comparison
Aspect	Class	Object
क्या है?	Blueprint or Template	Class से बना actual instance
Memory	Memory में तभी आता है जब object बनता है	Memory में allocate होता है
इस्तेमाल	Structure define करने के लिए	Real-world उपयोग के लिए
________________________________________
✅ निष्कर्ष (Conclusion)
•	Java में class और object core concepts हैं।
•	Class एक template है और object उसका वास्तविक उपयोग।
•	Methods से आप code को modular और reusable बना सकते हैं।
🧾 Java में Object को Method Parameter के रूप में पास करना
Java में methods को primitive types (जैसे int, float) की तरह ही objects को भी parameters के रूप में भेजा जा सकता है।
🔑 महत्वपूर्ण बात:
Java में object को pass करने पर object का reference (पता) भेजा जाता है, ना कि उसकी copy।
इसका मतलब है कि method के अंदर किए गए बदलाव original object पर भी असर डालते हैं।
________________________________________
✅ उदाहरण के साथ समझें:
public class MyClass {
    // Attributes / Fields
    private int attribute1;
    private String attribute2;
    private double attribute3;

    // Constructor
    public MyClass(int attribute1, String attribute2, double attribute3) {
        this.attribute1 = attribute1;
        this.attribute2 = attribute2;
        this.attribute3 = attribute3;
    }

    // Method that receives object as parameter
    public void updateAttributes(MyClass obj) {
        obj.attribute1 = 999; // Change the value
        obj.attribute2 = "Updated"; // Change the string
        obj.attribute3 = 99.99; // Change the double
    }

    // Method to print object data
    public void display() {
        System.out.println("attribute1: " + attribute1);
        System.out.println("attribute2: " + attribute2);
        System.out.println("attribute3: " + attribute3);
    }

    // Main method to test
    public static void main(String[] args) {
        MyClass obj1 = new MyClass(10, "Original", 25.5);

        System.out.println("Before method call:");
        obj1.display();

        MyClass helper = new MyClass(0, "", 0.0);
        helper.updateAttributes(obj1); // Passing obj1 to method

        System.out.println("\nAfter method call:");
        obj1.display();  // Note: obj1 is changed
    }
}
________________________________________
🟢 Output:
Before method call:
attribute1: 10
attribute2: Original
attribute3: 25.5

After method call:
attribute1: 999
attribute2: Updated
attribute3: 99.99
________________________________________
🧠 समझने वाली बात:
•	जब हम obj1 को method में भेजते हैं, तो उसका reference पास होता है।
•	method के अंदर obj.attribute1 = 999 लिखने से obj1.attribute1 भी बदल गया।
•	इसका मतलब है कि objects pass by reference की तरह व्यवहार करते हैं (हालांकि Java strictly pass-by-value ही है, पर value of reference pass होता है)।
________________________________________
⚠️ ध्यान दें:
यदि आप method के अंदर object को नया object assign कर दें, तो वो original object पर असर नहीं करेगा:
public void changeObject(MyClass obj) {
    obj = new MyClass(0, "New", 0.0); // ये बदलाव बाहर असर नहीं करेगा
}
क्यों? क्योंकि यहाँ obj को नया reference मिल रहा है, लेकिन original reference (obj1) नहीं बदला।
________________________________________
📌 निष्कर्ष (Conclusion):
•	Java में method को object pass करने पर reference भेजा जाता है।
•	Method के अंदर किए गए बदलाव original object को affect करते हैं।
•	लेकिन यदि आप object को नया object assign करें, तो वो बदलाव बाहर reflect नहीं होता।
🔁 Method Overloading in Java
Method Overloading का मतलब होता है:
एक ही नाम के एक से अधिक methods, लेकिन parameters अलग।
________________________________________
✅ Method Overloading क्यों ज़रूरी है?
मान लीजिए आपको जोड़ने (addition) का काम करना है, लेकिन कभी दो नंबरों का जोड़ करना है और कभी तीन का।
आप ऐसा कर सकते हैं:
sum2num(int a, int b)
sum3num(int a, int b, int c)
लेकिन यह पढ़ने में थोड़ा confusing हो सकता है क्योंकि दोनों methods का काम तो एक जैसा है।
इसलिए हम एक ही नाम sum() को रखते हैं, और Java समझ जाएगा कि कौन सा version चलाना है based on parameters।
________________________________________
🎯 Method Overloading कैसे करें?
✅ 1. Number of Parameters बदलकर
class OverloadExample {
    static void display(int a) {
        System.out.println("1 argument: " + a);
    }

    static void display(int a, int b) {
        System.out.println("2 arguments: " + a + ", " + b);
    }

    public static void main(String[] args) {
        display(5);
        display(10, 20);
    }
}
Output:
1 argument: 5  
2 arguments: 10, 20
________________________________________
✅ 2. Data Type बदलकर
class OverloadExample2 {
    static void display(int a) {
        System.out.println("int: " + a);
    }

    static void display(String a) {
        System.out.println("String: " + a);
    }

    public static void main(String[] args) {
        display(100);       // int version
        display("Hello");   // String version
    }
}
________________________________________
❌ केवल Return Type बदलने से Overloading नहीं होता!
// यह error देगा
int display() { ... }
double display() { ... }
इसका कारण है: Compiler को फर्क नहीं पता चलता सिर्फ return type से, उसे parameters से फर्क समझ में आता है।
________________________________________
🔍 Method Overloading के Rules:
Rule	Valid?
Different number of parameters	✅ Valid
Different data types of parameters	✅ Valid
Same parameters but different return types	❌ Invalid
Different parameter order (with different types)	✅ Valid
उदाहरण:
void test(int a, double b) { }  
void test(double b, int a) { }  // VALID (parameter order अलग है)
________________________________________
📚 Real-World Example (Sum Method):
class Calculator {
    int sum(int a, int b) {
        return a + b;
    }

    int sum(int a, int b, int c) {
        return a + b + c;
    }

    double sum(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.sum(10, 20));
        System.out.println(calc.sum(5, 10, 15));
        System.out.println(calc.sum(3.5, 4.5));
    }
}
Output:
30  
30  
8.0
________________________________________
✅ निष्कर्ष (Conclusion)
•	Method Overloading एक ही नाम से कई methods बनाने की सुविधा देता है।
•	Overloading readability और flexibility बढ़ाता है।
•	Java compile time पर तय करता है कौन सा version चलेगा (Static Binding)।
•	Overloading parameters के आधार पर होता है, return type से नहीं।
🔧 Constructor क्या होता है?
Constructor एक special method होता है जो तब automatically call होता है जब आप किसी class का object बनाते हैं।
☑️ Constructor की विशेषताएँ:
•	इसका नाम class के नाम जैसा ही होता है।
•	इसमें कोई return type नहीं होता, यहाँ तक कि void भी नहीं।
•	इसका उपयोग object के initial setup के लिए किया जाता है।
________________________________________
🏗️ उदाहरण: Constructor
class Car {
    String model;

    // Constructor
    Car() {
        System.out.println("Constructor called!");
        model = "Toyota";
    }

    public static void main(String[] args) {
        Car myCar = new Car(); // Constructor is called here
        System.out.println("Model: " + myCar.model);
    }
}
Output:
Constructor called!
Model: Toyota
________________________________________
🧱 Types of Constructors
1. 🔹 No-Argument Constructor
class Student {
    Student() {
        System.out.println("No-arg constructor called");
    }
}
2. 🔸 Parameterized Constructor
class Student {
    String name;

    Student(String studentName) {
        name = studentName;
    }
}
3. 🟢 Default Constructor (Provided by Java compiler)
अगर आप खुद कोई constructor नहीं लिखते, तो Java automatic एक default constructor बना देता है।
class Student {
    int age;
}
ऊपर के code में, Java internally ऐसा constructor देगा:
Student() {
    super(); // Object class का constructor call
}
________________________________________
🔁 Constructor Overloading क्या है?
एक ही class में कई constructors हो सकते हैं, parameters अलग-अलग होने चाहिए। इसे constructor overloading कहते हैं।
📌 उदाहरण:
class Language {
    String name;

    // No-arg constructor
    Language() {
        name = "Java";
    }

    // Parameterized constructor
    Language(String lang) {
        name = lang;
    }

    void getName() {
        System.out.println("Programming Language: " + name);
    }

    public static void main(String[] args) {
        Language obj1 = new Language();
        Language obj2 = new Language("Python");

        obj1.getName(); // Output: Java
        obj2.getName(); // Output: Python
    }
}
________________________________________
❗ Constructor के बारे में महत्वपूर्ण बातें:
Rule / Concept	Description
Constructor का नाम class के नाम जैसा हो	✅ हाँ
Return type हो	❌ नहीं (void भी नहीं होना चाहिए)
Overload किया जा सकता है	✅ हाँ
Override किया जा सकता है	❌ नहीं
Static/Abstract/Final constructor	❌ Java में संभव नहीं
________________________________________
🔚 निष्कर्ष (Conclusion)
•	Constructor एक विशेष method है जो object बनाते ही call होता है।
•	Constructor का काम होता है object को initialize करना।
•	हम constructor को overload कर सकते हैं ताकि एक ही class के object को अलग-अलग तरीकों से initialize किया जा सके।
•	अगर आप constructor नहीं बनाएंगे, तो Java खुद default constructor देगा।
🌳 क्या है Inheritance?
Inheritance (विरासत) एक ऐसी तकनीक है जिससे एक class (child) दूसरी class (parent) की properties (variables) और behaviors (methods) को reuse कर सकती है।
यह OOP (Object-Oriented Programming) का बहुत महत्वपूर्ण स्तंभ है।
________________________________________
🧬 Inheritance क्यों उपयोग करें?
✅ Code Reusability – पहले से बने methods का दोबारा उपयोग
✅ Method Overriding – Polymorphism के लिए
✅ IS-A Relationship दिखाने के लिए
✅ Cleaner Code – कम repetition
________________________________________
📚 Java Inheritance Syntax
class Parent {
    void display() {
        System.out.println("I am the parent.");
    }
}

class Child extends Parent { // "extends" keyword
    void show() {
        System.out.println("I am the child.");
    }
}

public class Main {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.display(); // inherited method
        obj.show();    // own method
    }
}
________________________________________
👪 Important Terms
Term	Meaning
Superclass	Parent/base class
Subclass	Child/derived class
extends	Keyword to inherit a class
IS-A	Relationship shown via inheritance
________________________________________
🔢 Types of Inheritance in Java
Java में class-based inheritance के 3 types होते हैं (interfaces के ज़रिए बाकी भी support होते हैं):
1️⃣ Single Inheritance
एक class दूसरी एक class से inherit करती है।
class Animal {
    void eat() {
        System.out.println("eating...");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("barking...");
    }
}
⏩ Output:
barking...
eating...
________________________________________
2️⃣ Multilevel Inheritance
एक class एक class से inherit करती है और दूसरी उससे।
class Animal {
    void eat() { System.out.println("eating..."); }
}

class Dog extends Animal {
    void bark() { System.out.println("barking..."); }
}

class BabyDog extends Dog {
    void weep() { System.out.println("weeping..."); }
}
⏩ Output:
weeping...
barking...
eating...
________________________________________
3️⃣ Hierarchical Inheritance
एक superclass से कई subclasses inherit करते हैं।
class Animal {
    void eat() { System.out.println("eating..."); }
}

class Dog extends Animal {
    void bark() { System.out.println("barking..."); }
}

class Cat extends Animal {
    void meow() { System.out.println("meowing..."); }
}
⏩ Output:
meowing...
eating...
Note: c.bark() नहीं कर सकते क्योंकि Cat class में bark() नहीं है।
________________________________________
🚫 Java में क्या संभव नहीं है?
❌ Multiple Inheritance via classes:
class A {}
class B {}
class C extends A, B {} // ❌ Error
Java में multiple inheritance via classes allow नहीं है क्योंकि ambiguity (confusion) हो सकती है — इसे interfaces के ज़रिए achieve किया जाता है।
________________________________________
📌 Real-life Example:
class Vehicle {
    int speed = 60;
}

class Car extends Vehicle {
    String brand = "Toyota";
}

public class Test {
    public static void main(String[] args) {
        Car myCar = new Car();
        System.out.println(myCar.speed);  // inherited
        System.out.println(myCar.brand);  // own
    }
}
________________________________________
🧠 Bonus Tip: Method Overriding
अगर subclass उसी नाम का method define करता है जो superclass में है, तो वो method override हो जाता है।
class Animal {
    void sound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}
________________________________________
✅ Summary Table:
Inheritance Type	Supported in Java?	Example
Single Inheritance	✅ Yes	Dog → Animal
Multilevel Inheritance	✅ Yes	BabyDog → Dog → Animal
Hierarchical Inheritance	✅ Yes	Dog, Cat → Animal
Multiple Inheritance	❌ No (via class)	Only via interface
Hybrid Inheritance	❌ No (via class)	Only via interface
📘 What is Method Overriding in Java?
Method Overriding तब होता है जब:
•	A child class provides a specific implementation of a method
•	That method already exists in the parent class
•	Method name, parameters, and return type must be the same
🔁 This allows runtime polymorphism in Java — meaning method resolution happens at runtime based on the object.
________________________________________
🧪 Basic Example of Overriding:
class Parent {
    void show() {
        System.out.println("Parent's show()");
    }
}

class Child extends Parent {
    @Override
    void show() {
        System.out.println("Child's show()");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj1 = new Parent();
        obj1.show();  // Output: Parent's show()

        Parent obj2 = new Child();
        obj2.show();  // Output: Child's show() – runtime polymorphism
    }
}
________________________________________
⚖️ Rules of Method Overriding in Java
Rule #	Description	Example / Notes
1️⃣	Same method name, parameters, return type	Signature must be identical
2️⃣	Access modifier in child must be same or more accessible	protected → public ✅, but public → private ❌
3️⃣	Final methods cannot be overridden	Compiler error
4️⃣	Static methods are not overridden, they are hidden	This is called method hiding
5️⃣	Private methods cannot be overridden	They are not inherited
6️⃣	From Java 5, return types can differ if the child return type is a subtype – called covariant return	
7️⃣	Use super.method() to call parent version from child	Useful in logging, partial overrides
________________________________________
📌 Important Concepts Illustrated
✅ Access Modifier Rule
class Parent {
    protected void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    @Override
    public void greet() { // More accessible ✅
        System.out.println("Hello from Child");
    }
}
________________________________________
❌ Final Method
class Parent {
    final void greet() {
        System.out.println("Final method");
    }
}

class Child extends Parent {
    // void greet() {} // ❌ Compile-time error
}
________________________________________
❌ Static Method Hiding (Not Overriding)
class Parent {
    static void display() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    static void display() {
        System.out.println("Child static");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.display(); // Output: Parent static → method hiding
    }
}
________________________________________
✅ Private Method: Not Overridden
class Parent {
    private void secret() {
        System.out.println("Parent secret");
    }

    public void show() {
        secret(); // calls Parent's secret
    }
}

class Child extends Parent {
    private void secret() {
        System.out.println("Child secret");
    }

    public void show() {
        secret(); // calls Child's secret
    }
}
________________________________________
✅ Covariant Return Type (since Java 5)
class Parent {
    Object getValue() {
        return "Parent";
    }
}

class Child extends Parent {
    @Override
    String getValue() {
        return "Child";
    }
}
________________________________________
✅ Calling Superclass Method in Overridden Method
class Parent {
    void show() {
        System.out.println("Parent show");
    }
}

class Child extends Parent {
    @Override
    void show() {
        super.show(); // call parent's show
        System.out.println("Child show");
    }
}
________________________________________
🎯 Method Overriding vs Method Overloading
Feature	Overriding	Overloading
Purpose	Run-time polymorphism	Compile-time polymorphism
Class Level	Across parent-child classes	Within the same class
Method Signature	Must be same	Must be different (params)
Return Type	Must be same or covariant	Can be different
Access Modifier	Must be same or more accessible	No restriction
________________________________________
📝 Summary Checklist
✅ Same method name, parameters, return type
✅ Subclass method can widen access (e.g., protected → public)
❌ Final, static, or private methods can't be overridden
✅ Return type can be covariant
✅ Overridden method can call super.method()
✅ Enables dynamic dispatch (i.e., runtime polymorphism)

Multithreading in Java (मल्टीथ्रेडिंग क्या है?)
Multithreading का मतलब है एक साथ कई tasks (threads) को चलाना। इससे CPU का पूरा उपयोग होता है और performance बेहतर होती है।
✅ Multithreading के फायदे:
1.	एक साथ कई काम (Tasks) हो सकते हैं (Time बचता है)
2.	Memory share होती है, जिससे efficiency बढ़ती है
3.	एक Thread fail हो जाए तो बाकी चलते रहते हैं
________________________________________
🔸 Thread Life Cycle in Java (थ्रेड की अवस्थाएँ)
State (अवस्था)	Explanation (विवरण)
New	Thread बनाया गया है पर start नहीं किया गया
Runnable	Thread ready है चलने के लिए
Running	Thread run() method execute कर रहा है
Blocked	Resource lock होने के कारण रुका हुआ
Waiting	दूसरी thread से signal का इंतज़ार
Timed Waiting	कुछ समय के लिए रुका हुआ
Terminated (Dead)	काम पूरा होने या stop होने के बाद
🌟 Use case Example:
Thread thread = new Thread(() -> {
    System.out.println("Thread is running...");
});
thread.start(); // Runnable
Thread.sleep(1000); // Timed Waiting
thread.join(); // Waiting
// Thread ends – Terminated
________________________________________
🔹 Thread Creation (Java में थ्रेड कैसे बनाते हैं?)
1️⃣ By extending Thread class:
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();
    }
}
2️⃣ By implementing Runnable interface:
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running...");
    }
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start();
    }
}
📌Runnable का फायदा है कि आप class को extend किए बिना thread बना सकते हैं।
________________________________________
🔸 Important Thread Methods (महत्वपूर्ण थ्रेड मेथड्स)
Method	Use (उपयोग)
start()	Thread शुरू करता है
run()	Thread का actual काम
sleep(ms)	Thread को कुछ देर सुलाना
join()	दूसरे Thread का इंतजार
getName()/setName()	Thread का नाम पाना/सेट करना
interrupt()	Thread को रोकने का संकेत देना
isAlive()	Thread चल रहा है या नहीं, जाँचना
yield()	Thread voluntarily control छोड़े
________________________________________
🔹 Synchronization in Java (सिंक)
जब multiple threads एक ही resource को access करते हैं, तो synchronization जरूरी होता है।
✅ क्यों जरूरी?
1.	Data corruption से बचाव
2.	Race condition रोकना
🔐 Synchronization के तरीके:
1.	synchronized method
2.	synchronized block
3.	static synchronization
________________________________________
🔸 Exception Handling in Java (अपवाद प्रबंधन)
❓ Exception क्या है?
यह एक runtime error है जो program को रोक सकती है।
⚠️ Exception Handling के फायदे:
1.	Program का normal flow maintain होता है
2.	Errors को handle करके user-friendly message दिखा सकते हैं
🌳 Hierarchy:
Throwable
 ├── Exception (checked + unchecked)
 │    ├── IOException
 │    ├── SQLException
 │    └── RuntimeException
 │         ├── NullPointerException
 │         ├── ArithmeticException
 │         └── ArrayIndexOutOfBoundsException
 └── Error (e.g., OutOfMemoryError)
🔁 Try-Catch Block:
try {
    int a = 50 / 0;
} catch (ArithmeticException e) {
    System.out.println("Can't divide by zero");
}
________________________________________
✅ Summary (सारांश):
•	Java में Multithreading से एक साथ कई tasks efficiently किए जा सकते हैं।
•	Thread Life Cycle को समझने से हम सही तरीके से thread को manage कर पाते हैं।
•	Runnable interface या Thread class से हम threads बना सकते हैं।
•	Synchronization shared resources के लिए जरूरी है।
•	Exception Handling से हम runtime errors को manage कर सकते हैं।
🌟 Java Exception Handling (सारांश)
Exception मतलब ऐसा error जो program के normal flow को disturb करता है। Java में इन्हें handle करने के लिए try-catch, throw, throws आदि का प्रयोग किया जाता है।
________________________________________
📚 Types of Exceptions (Java में Exception के प्रकार)
Java में तीन प्रकार के Exceptions होते हैं:
1. ✅ Checked Exceptions (Compile Time Error)
•	ये compile time पर check किए जाते हैं।
•	Compiler आपको warning देगा कि इसे handle करो या declare करो।
•	Examples:
o	IOException
o	SQLException
o	FileNotFoundException
2. ⚠️ Unchecked Exceptions (Run Time Error)
•	इन्हें compile time पर check नहीं किया जाता।
•	Run time पर error आता है।
•	Examples:
o	ArithmeticException
o	NullPointerException
o	ArrayIndexOutOfBoundsException
3. ❌ Error
•	ये serious problems होती हैं, जो recover नहीं की जा सकती।
•	Examples:
o	OutOfMemoryError
o	StackOverflowError
________________________________________
🔑 Java Exception Handling Keywords
Keyword	Description (हिंदी में)
try	Risky code यहाँ लिखा जाता है जो exception दे सकता है
catch	Exception को handle करता है
finally	यह block हमेशा execute होता है
throw	Manually exception फेंकने के लिए
throws	Method के declaration में exception बताने के लिए
________________________________________
🧪 Example: try-catch Block
public class Example {
    public static void main(String[] args) {
        try {
            int data = 100 / 0;
        } catch (ArithmeticException e) {
            System.out.println(e); // prints: java.lang.ArithmeticException: / by zero
        }
        System.out.println("rest of the code...");
    }
}
👉 अगर try block में exception आए, तो catch उसे handle करता है और program आगे चलता है।
________________________________________
💥 Common Unchecked Exceptions (with examples)
1.	ArithmeticException
int a = 50 / 0; // Divide by zero
2.	NullPointerException
String s = null;
System.out.println(s.length()); // Null access
3.	NumberFormatException
String s = "abc";
int i = Integer.parseInt(s); // Cannot convert
4.	ArrayIndexOutOfBoundsException
int[] arr = new int[5];
System.out.println(arr[10]); // Invalid index
________________________________________
🧱 Built-in vs User-defined Exceptions
Built-in Exception
•	Java में पहले से बनी होती हैं
•	Examples: NullPointerException, IOException
User-defined Exception
•	Programmer खुद define करता है
class MyException extends Exception {
    MyException(String message) {
        super(message);
    }
}
________________________________________
🎯 Example: User-defined Exception
class CustomException extends Exception {
    public CustomException(String msg) {
        super(msg);
    }
}

public class Test {
    public static void main(String[] args) {
        try {
            throw new CustomException("This is custom exception");
        } catch (CustomException e) {
            System.out.println(e.getMessage());
        }
    }
}
________________________________________
🔁 Difference: Checked vs Unchecked Exceptions
Feature	Checked Exception	Unchecked Exception
Compile time check	Yes	No
Package	java.io, java.sql आदि	java.lang
Inherits from	Exception (not RuntimeException)	RuntimeException
Must be handled	Yes (try-catch or throws)	Optional
Examples	IOException, SQLException	NullPointerException, ArithmeticException
________________________________________
🔧 throw vs throws
Keyword	Usage
throw	Exception को manually फेंकने के लिए
throws	Method के साथ exception declare करने के लिए
// throw example
throw new ArithmeticException("Not allowed");

// throws example
public void readFile() throws IOException
________________________________________
🧪 Example: throw + unchecked exception
public class Voting {
    static void validate(int age) {
        if(age < 18)
            throw new ArithmeticException("Not eligible to vote");
        else
            System.out.println("Eligible");
    }

    public static void main(String[] args) {
        validate(13); // Exception
    }
}
________________________________________
🧪 Example: throw + checked exception
import java.io.*;

public class Test {
    static void readFile() throws FileNotFoundException {
        throw new FileNotFoundException("File not found!");
    }

    public static void main(String[] args) {
        try {
            readFile();
        } catch(FileNotFoundException e) {
            System.out.println(e);
        }
    }
}
________________________________________
🔄 Difference: final, finally, finalize
Keyword	Use-case
final	Constant बनाने के लिए, method को override से रोकने के लिए
finally	Exception हो या न हो, यह block हमेशा चलेगा
finalize	Garbage collection से पहले object cleanup के लिए
________________________________________
🔍 Examples
🔒 final keyword
final int age = 18;
age = 25; // Error
✅ finally block
try {
    int data = 50 / 0;
} catch (ArithmeticException e) {
    System.out.println("Caught");
} finally {
    System.out.println("Always executed");
}
🧹 finalize method
protected void finalize() {
    System.out.println("Object cleaned up");
}
________________________________________
🔚 Without Exception Handling vs With Exception Handling
❌ Without handling
int data = 50 / 0;
System.out.println("rest of the code"); // never runs
✅ With try-catch
try {
    int data = 50 / 0;
} catch (ArithmeticException e) {
    System.out.println(e);
}
System.out.println("rest of the code"); // runs
________________________________________
✅ Conclusion (निष्कर्ष)
Java Exception Handling एक powerful mechanism है जो errors को catch करने, handle करने और program को crash होने से बचाने का तरीका देता है। Checked, Unchecked, और User-defined exception को सही ढंग से handle करने से code ज्यादा robust और safe बनता है।
🧠 Virtual Methods in Java
C++ में हम virtual keyword का use करते हैं virtual functions के लिए, लेकिन Java में सभी non-final, non-static, non-private instance methods by default virtual होते हैं.
🔁 क्या होता है Virtual Method?
Virtual method एक ऐसा method होता है जिसे child class override कर सकती है और runtime पर Java यह decide करता है कि कौन-सा method run होगा — इसे कहते हैं runtime polymorphism या dynamic dispatch.
🧪 Example:
class Parent {
    void v1() {
        System.out.println("Inside Parent Class");
    }
}

class Child extends Parent {
    void v1() {
        System.out.println("Inside Child Class");
    }

    public static void main(String args[]) {
        Parent obj = new Child();  // Parent reference, Child object
        obj.v1();                  // Output: Inside Child Class
    }
}
📌 Important Points:
•	Method same name और parameters से override होना चाहिए.
•	Method final, private, या static नहीं होना चाहिए.
•	IS-A relationship (inheritance) होना चाहिए.
________________________________________
🧱 Abstract Classes and Methods
🔍 Abstraction:
Data abstraction मतलब — unnecessary details को hide करना और सिर्फ जरूरी information को show करना.
Java में abstraction achieve किया जा सकता है:
•	Abstract class से
•	Interface से
🧩 Abstract Class क्या होती है?
•	Abstract class एक ऐसी class होती है जिससे हम object नहीं बना सकते.
•	इसमें abstract methods और normal methods दोनों हो सकते हैं.
•	इसे inherit किया जाता है किसी subclass से, जहां abstract method को implement करना पड़ता है.
🧪 Example:
// Abstract class
abstract class Animal {
    // Abstract method (no body)
    public abstract void animalSound();

    // Regular method
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Subclass
class Pig extends Animal {
    public void animalSound() {
        System.out.println("The pig says: wee wee");
    }
}

class Main {
    public static void main(String[] args) {
        Pig myPig = new Pig();
        myPig.animalSound();  // Output: The pig says: wee wee
        myPig.sleep();        // Output: Zzz
    }
}
📌 Rules of Abstract Class:
Rule No.	Description
1	Class को abstract keyword से declare करना होता है
2	इसमें abstract + non-abstract methods हो सकते हैं
3	इससे object नहीं बनाया जा सकता
4	इसमें final, static methods और constructor भी हो सकते हैं
5	Abstract methods को subclass में implement करना ज़रूरी है
________________________________________
🔁 Summary (Recap)
Concept	Java में Behavior
Virtual Method	By default every method (non-static, non-final, non-private) virtual होता है
Abstract Class	Object नहीं बनता, methods को subclass में implement करना पड़ता है
Abstract Method	Method without body, subclass implement करता है
Final Method	Override नहीं हो सकता
Static Method	Override नहीं किया जा सकता, hence virtual नहीं होता
Private Method	Subclass में accessible नहीं, override नहीं होता
🔶 Features of Abstract Class in Java
Abstract class Java में एक ऐसा powerful concept है जो abstraction provide करता है और object-oriented design को simple और manageable बनाता है। नीचे इसके key features हैं:
________________________________________
1️⃣ Template (ढांचा प्रदान करता है)
Abstract class ek template (ढांचा) की तरह काम करता है जिसमें कुछ methods define होते हैं और कुछ methods सिर्फ declare किए जाते हैं (abstract)। Subclass उन declared methods को implement करता है।
🧠 It gives a base structure to subclasses.
abstract class Vehicle {
    abstract void start(); // just declared
    void fuel() { System.out.println("Petrol"); } // regular method
}
________________________________________
2️⃣ Loose Coupling (कम dependencies)
Abstract class का use करने से classes के बीच की dependency कम हो जाती है, जिससे code loosely coupled बनता है और maintain करना आसान होता है।
🧠 Loose coupling = flexible और scalable design.
________________________________________
3️⃣ Code Reusability (कोड दोबारा use करना)
Abstract class में जो भी non-abstract methods होते हैं, उन्हें हम बार-बार use कर सकते हैं। इससे हमें बार-बार वही code लिखने की जरूरत नहीं होती।
🧠 Time बचता है, और error भी कम होते हैं।
abstract class Animal {
    void eat() { System.out.println("Eating..."); }
    abstract void sound();
}
________________________________________
4️⃣ Abstraction (Implementation छुपाना)
Abstract class हमें implementation को hide करने की सुविधा देता है और सिर्फ जरूरी behavior (method signatures) को expose करता है।
🧠 User को क्या करना है दिखता है, कैसे करना है नहीं दिखता।
________________________________________
5️⃣ Dynamic Resolution (Run-time पर method call decide होता है)
Java में abstract methods को override किया जाता है subclass में और runtime पर Java decide करता है कि कौन-सा method call होगा — इसे कहते हैं dynamic method dispatch.
🧠 This supports polymorphism — same method name, different behaviors.
Animal obj = new Dog(); // Dog is subclass of Animal
obj.sound(); // Output: Bark (Dog's version of sound())
________________________________________
🔑 Summary Table
Feature	Description (Hindi-English Mix)
Template	Abstract class ek ढांचा (structure) provide करता है
Loose Coupling	कम dependency, flexible code
Code Reusability	Non-abstract methods बार-बार use कर सकते हैं
Abstraction	Implementation को छुपाता है, सिर्फ जरूरी चीज़ें दिखाता है
Dynamic Resolution	Run-time पर decide होता है कौन-सा method call होगा
🔷 Java Interface क्या है?
Java में interface एक blueprint (खाका) होता है class का। इसका use हम abstraction और multiple inheritance achieve करने के लिए करते हैं।
👉 Interface में सिर्फ:
•	Abstract methods होते हैं (method का सिर्फ नाम होता है, body नहीं)
•	Static final variables होते हैं (constants)
Example:
interface Animal {
    void sound(); // abstract method
}
________________________________________
🧠 Interface की Important बातें
Point	Explanation (Hindi-English Mix)
1. Blueprint	Interface सिर्फ structure (method signatures) define करता है
2. Abstract Methods	इसमें केवल abstract methods होते हैं (Java 7 तक)
3. Method Body नहीं	Java 7 तक methods के लिए कोई body allowed नहीं थी
4. IS-A Relationship	Interface inheritance को show करता है (Dog IS-A Animal)
5. Instantiation Not Allowed	Interface से object नहीं बना सकते
6. Java 8 से: default और static methods add हुए जिनके पास body हो सकती है	
7. Java 9 से: private methods भी allowed हुए interface में	
________________________________________
🔶 Example:
interface Vehicle {
    void start(); // abstract method
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}
Output:
Car starts with key
________________________________________
✅ Advantages of Interface in Java
1️⃣ Achieve Abstraction (जैसे abstract class)
Interface completely abstraction provide करता है — implementation hidden रहता है।
2️⃣ Multiple Inheritance Support
Java class एक से ज़्यादा interfaces को implement कर सकती है — जिससे multiple inheritance possible होता है।
interface A { void msg(); }
interface B { void display(); }

class C implements A, B {
    public void msg() { ... }
    public void display() { ... }
}
3️⃣ Loose Coupling Design
Interface loosely coupled architecture को promote करता है, जिससे flexible and scalable code बनता है।
4️⃣ Polymorphism Achieve करना
Interface के through हम runtime polymorphism achieve कर सकते हैं।
Vehicle v = new Car(); // Interface reference
v.start(); // Polymorphic behavior
5️⃣ Support for Callbacks / Contracts
Interface ek contract की तरह काम करता है, जो force करता है कि हर implementing class required methods को define करे।
________________________________________
🔚 Conclusion (सारांश)
•	Interface एक powerful tool है जो abstraction और multiple inheritance को support करता है।
•	Java 8 और 9 के बाद interface और भी flexible हो गया है (default, static, private methods).
•	Interface का use करके हम better design, maintainable और loosely coupled code बना सकते हैं।
🔄 What is Method Overriding?
जब child class (subclass) अपने parent class की किसी method को same name और parameters के साथ दोबारा define करती है — तो उसे Method Overriding कहते हैं।
👉 Simple Words में:
Parent class ने एक method define की —
Child class उसी method को अपने तरीके से implement कर रहा है — same नाम और arguments के साथ — यही है method overriding.
________________________________________
🎯 Why Use Method Overriding?
1.	✅ Customize करना superclass की functionality
(Parent class generic काम करता है, child class specific)
2.	✅ Runtime polymorphism achieve करना
(Object के base पर कौन सी method call होगी, ये run time पे decide होता है)
________________________________________
✅ Rules for Method Overriding in Java
Rule No.	Rule (Hindi-English)
1️⃣	Method का same name होना चाहिए जैसे parent class में
2️⃣	Method के parameters भी same होने चाहिए
3️⃣	Classes में IS-A relationship (inheritance) होना जरूरी है
4️⃣	Overridden method को access modifier कम restrictive नहीं बना सकते (private नहीं कर सकते)
5️⃣	Method को final, static, या constructor नहीं होना चाहिए
________________________________________
🔧 Example of Method Overriding
// Parent class
class Vehicle {
    void run() {
        System.out.println("Vehicle is running");
    }
}

// Child class
class Bike2 extends Vehicle {
    void run() {
        System.out.println("Bike is running safely");
    }

    public static void main(String args[]) {
        Bike2 obj = new Bike2(); // object create
        obj.run(); // calling method
    }
}
🟩 Output:
Bike is running safely
________________________________________
🤔 कैसे काम किया?
•	Vehicle class ने run() method दी थी।
•	Bike2 class ने उसी run() method को override कर दिया — अब जब Bike2 का object से run() call हुआ, तो child class वाली method चली।
________________________________________
💡 Bonus: Dynamic Method Dispatch
Vehicle v = new Bike2();
v.run(); // Still prints "Bike is running safely"
यह है runtime polymorphism का example — object Bike2 का है, लेकिन reference Vehicle का है।
________________________________________
🧠 Summary
•	Method overriding → same method name + same parameters + inheritance
•	Used for runtime polymorphism
•	Allows custom behavior in child classes
•	Follow all overriding rules (same signature, no private/final/static)
🔷 Polymorphism in Java (बहुरूपता)
👉 Meaning (मतलब):
Polymorphism का मतलब होता है — "many forms" यानी एक ही चीज़ के कई रूप।
Java में यह तब होता है जब multiple classes आपस में inheritance के ज़रिए related होती हैं — और वे same method name के साथ different काम करती हैं।
________________________________________
📌 Example से समझो:
मान लो एक parent class है Animal और उसके अंदर एक method है animalSound()।
अब कई subclasses बन सकते हैं — जैसे:
🐷 Pig → "wee wee" बोलेगा
🐶 Dog → "bow wow" बोलेगा
🐱 Cat → "meow" बोलेगा
हर subclass same method (animalSound()) को अपने तरीके से implement करेगा।
________________________________________
🔧 Java Example:
// Superclass
class Animal {
    public void animalSound() {
        System.out.println("The animal makes a sound");
    }
}

// Subclass 1
class Pig extends Animal {
    public void animalSound() {
        System.out.println("The pig says: wee wee");
    }
}

// Subclass 2
class Dog extends Animal {
    public void animalSound() {
        System.out.println("The dog says: bow wow");
    }
}

// Main Class
class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // Animal object
        Animal myPig = new Pig();        // Pig object as Animal reference
        Animal myDog = new Dog();        // Dog object as Animal reference

        myAnimal.animalSound();
        myPig.animalSound();
        myDog.animalSound();
    }
}
________________________________________
🟩 Output:
The animal makes a sound
The pig says: wee wee
The dog says: bow wow
________________________________________
🎯 Key Points (मुख्य बातें):
Concept	Explanation
Polymorphism	एक ही method name, लेकिन अलग-अलग classes में अलग behavior
Runtime Polymorphism	Method call runtime पर decide होती है — कौन सी class की method चलेगी
Inheritance जरूरी है	Parent class से subclass inherit होना चाहिए
Method Overriding	Polymorphism का main हिस्सा है
________________________________________
🔁 Types of Polymorphism in Java:
Type	Description
1. Compile-time Polymorphism	Method Overloading (same class में same नाम के multiple methods)
2. Runtime Polymorphism	Method Overriding (parent-child classes में same method redefine होती है)
________________________________________
🧠 Summary (सारांश):
•	Polymorphism = One interface, many implementations
•	एक ही method (animalSound) कई अलग-अलग classes में अलग behavior दिखा सकती है।
•	इससे code flexibility और readability बढ़ती है।
🔷 Interface in Java
🔹 Interface क्या है?
Java में interface एक ऐसा structure है जो सिर्फ़:
•	abstract methods (यानी सिर्फ़ declaration, कोई body नहीं),
•	और constants (जो public static final होते हैं) को ही contain कर सकता है।
💡 Interface से हम pure abstraction achieve करते हैं।
________________________________________
🔹 Interface के features:
Feature	Detail
1️⃣	Interface के methods by default public abstract होते हैं
2️⃣	Variables हमेशा public static final होते हैं (constant)
3️⃣	Interface में constructors नहीं होते
4️⃣	Interface can have abstract, default, static, और Java 9 से private methods
5️⃣	एक class multiple interfaces implement कर सकती है
________________________________________
🧱 Interface कैसे declare करें?
public interface MyInterface {
    int x = 10;      // public static final by default
    void show();     // public abstract by default
}
➡ Java compiler अपने आप ही public, abstract, static, final keywords add कर देता है।
________________________________________
✅ Interface को Implement करना
जब कोई class किसी interface को implement करती है, तो उसे interface के सभी methods का body देना होता है।
interface MyInterface {
    void show();
    void display();
}

class MyClass implements MyInterface {
    public void show() {
        System.out.println("Show method implemented");
    }

    public void display() {
        System.out.println("Display method implemented");
    }
}
________________________________________
✅ Multiple Interfaces को Implement करना
interface A {
    void show();
}

interface B {
    void display();
}

class MyClass implements A, B {
    public void show() {
        System.out.println("A's show");
    }

    public void display() {
        System.out.println("B's display");
    }
}
________________________________________
🔁 Interface को Extend करना
एक interface दूसरे interface को extends keyword से inherit कर सकता है:
interface A {
    void methodA();
}

interface B extends A {
    void methodB();
}
अब अगर कोई class B implement करती है, तो उसे methodA() और methodB() दोनों को implement करना होगा।
class MyClass implements B {
    public void methodA() {
        System.out.println("methodA implemented");
    }

    public void methodB() {
        System.out.println("methodB implemented");
    }
}
________________________________________
🎯 क्यों use करते हैं Interface?
Reason No.	Description
1️⃣	Large projects में architecture-level design interface से किया जाता है
2️⃣	Interface को API की तरह third-party vendors को expose किया जा सकता है
3️⃣	Different objects के लिए अलग-अलग implementation possible है
4️⃣	Interface से full abstraction मिलता है
5️⃣	Java में multiple inheritance interface से possible है
________________________________________
🧠 Important Rules:
1.	Class को interface implement करने पर सभी abstract methods को public modifier से define करना जरूरी है।
2.	अगर class किसी method को implement नहीं करती, तो उसे abstract declare करना पड़ेगा।
3.	एक class extends कर सकती है किसी class को, और साथ में implements कर सकती है एक या multiple interfaces को।
________________________________________
🔧 Java 8 & 9 Additions in Interface:
Java Version	Feature
Java 8	default और static methods interface में allowed हैं
Java 9	private methods भी add कर सकते हैं interface में

interface MyInterface {
    default void show() {
        System.out.println("This is a default method");
    }

    static void staticMethod() {
        System.out.println("Static method in interface");
    }

    private void helper() {
        System.out.println("Private method (Java 9+)");
    }
}
________________________________________
🔚 Summary (सारांश):
•	Interface सिर्फ़ abstract methods और constants रखता है।
•	Class implement करती है interface को — और methods को override करती है।
•	Interface को extend भी किया जा सकता है — जैसे classes को करते हैं।
•	Interface से abstraction, flexibility और multiple inheritance achieve किया जाता है।
🔶 What is a Package in Java?
Java में Package एक folder/directory की तरह होता है जिसमें logically related classes, interfaces और sub-packages रखे जाते हैं। इसका main purpose होता है —
👉 code को organize करना,
👉 naming conflict से बचना,
👉 और code reusability देना।
________________________________________
🎯 क्यों ज़रूरत पड़ी Package की?
छोटे projects में सभी Java files को एक ही folder में रखना आसान होता है।
लेकिन बड़े projects में:
•	कई modules और हजारों classes होती हैं।
•	Same name वाली files हो सकती हैं (जैसे Student.java कई बार आ सकता है)।
•	ऐसे में naming conflict हो सकता है।
इसलिए Java में packages यूज़ किए जाते हैं, ताकि हर class अपने अलग package (folder) में रहे और code अच्छा organized रहे।
________________________________________
🧾 Package Real Life Example
जैसे आप अपनी files अलग-अलग folders में रखते हो (Movies, Songs, Documents etc.) — वैसे ही:
📂 com.companyname.project.module
हर folder एक package की तरह है, जो related चीजों को group करता है।
________________________________________
🔧 Types of Packages in Java
Type	Explanation
✅ Built-in Packages	Java के खुद के बने हुए packages जैसे: java.lang, java.util, java.io, etc.
✅ User-defined Packages	जो हम खुद create करते हैं अपने custom code के लिए
________________________________________
📦 Creating User-defined Package
Java में एक special keyword होता है — package, जिससे हम अपना package declare कर सकते हैं।
🔹 Syntax:
package mypackage;

public class A {
    public void show() {
        System.out.println("Inside class A");
    }
}
🔹 Important Points:
•	package statement हमेशा Java file की first line पर होनी चाहिए।
•	Folder का नाम और package का नाम same होना चाहिए।
•	Java file को compile करते वक्त proper folder में रखना होता है।
________________________________________
⚙️ Compile और Use कैसे करें?
🔹 Step 1: Create folder & save file
mypackage/
└── A.java
A.java
package mypackage;

public class A {
    public void msg() {
        System.out.println("Hello from package");
    }
}
🔹 Step 2: Compile
javac -d . A.java
🔹 -d . का मतलब है — compiled .class file को current directory में package folder (mypackage) के अंदर बनाओ।
🔹 Step 3: Use the class in another file
B.java
import mypackage.A;

class B {
    public static void main(String[] args) {
        A obj = new A();
        obj.msg();
    }
}
🔹 Step 4: Compile & Run
javac B.java
java B
________________________________________
📚 Built-in Packages Examples:
Package	Purpose
java.lang	Core language features (automatically imported)
java.util	Data structures (ArrayList, HashMap etc.)
java.io	Input/output
java.net	Networking
java.sql	Database connectivity
Use करने के लिए import करना पड़ता है:
import java.util.Scanner;
________________________________________
📌 Naming Convention for Packages
Java में package names हमेशा lowercase में होने चाहिए।
Example:
package com.ibm.hdfc.loan.homeloan;
यह breakdown है:
•	com – company domain
•	ibm – company name
•	hdfc – client/project name
•	loan – main module
•	homeloan – sub module
➡ इस तरह से naming से आपका code properly organized और readable बनता है।
________________________________________
🌟 Advantages of Using Packages
Benefit	Explanation
✅ Organized Structure	Project files का folder-wise अच्छा structure बनता है
✅ Reusability	Common code को बार-बार use कर सकते हैं
✅ Avoid Name Conflicts	दो same-name वाली classes अलग-अलग packages में रख सकते हैं
✅ Easy Maintenance	नए developers को जल्दी समझ आता है कि कौन सी class कहाँ है
✅ Access Protection	Classes और members की visibility control कर सकते हैं (default/package-private access)
________________________________________
📝 Summary
•	Package = folder containing related Java classes/interfaces
•	Use package keyword to define user-defined packages
•	Use import keyword to use package classes
•	Helps in organizing, avoiding name clashes, reusability
•	Java has many built-in packages (like java.util, java.io)
•	Follow lowercase naming convention for custom packages
🔷 AWT (Abstract Windowing Toolkit) in Java
🧠 Basic Concept:
Java में GUI (Graphical User Interface) बनाने के लिए AWT एक toolkit है जिसमें बहुत सारे pre-built components होते हैं जैसे – Button, Label, TextField, Checkbox, etc.
Ye components window-based application बनाने में use होते हैं.
________________________________________
🔸 Why AWT? (क्यों ज़रूरी है AWT?)
•	Command-line interface (CLI) से GUI better होता है user के लिए.
•	AWT platform-independent है – यानी जो GUI आप Windows पर बनाओगे, वो Mac/Linux पर भी चलेगा.
•	AWT native system के components का use करता है, जिससे "look and feel" same रहता है system के जैसा.
________________________________________
🔶 AWT Components
Component	Use
Label	Static text display करने के लिए
Button	कोई action perform करने के लिए
TextField	User input लेने के लिए
Checkbox	Multiple options में से select करने के लिए
RadioButton	(CheckboxGroup) – single choice
List	List of items
Choice	Drop-down
Scrollbar	Horizontal / Vertical scroll
TextArea	Multiline text input
________________________________________
🔶 AWT Containers
Container	Use
Frame	Main window create करने के लिए
Panel	Sub-container (components को group करने के लिए)
Window	Frame जैसा, लेकिन बिना title के
Dialog	Pop-up window (dependent on Frame)
Applet	Web-based GUI applications के लिए
________________________________________
🔷 Simple Example: Frame with Button
import java.awt.*;

public class MyFrame {
    public static void main(String[] args) {
        // Frame create karo
        Frame f = new Frame("My First AWT App");

        // Button create karo
        Button b = new Button("Click Me");
        b.setBounds(100, 100, 80, 30); // x, y, width, height

        // Frame में button add karo
        f.add(b);

        f.setSize(300, 200);  // Frame size set karo
        f.setLayout(null);    // Layout manager off
        f.setVisible(true);   // Frame show karo
    }
}
🧾 Output:
A window खुलेगी with a button "Click Me".
________________________________________
🔷 Components + Container Diagram
+-----------------------------+
|        Frame (Container)   |
|   +---------------------+  |
|   |     Button (Comp)   |  |
|   |     Label (Comp)    |  |
|   |     TextField       |  |
|   +---------------------+  |
+-----------------------------+
________________________________________
🔶 Applet Example using AWT
import java.awt.*;
import java.applet.*;

public class MyApplet extends Applet {
    public void init() {
        add(new Label("Enter your name:"));
        add(new TextField(20));
        add(new Button("Submit"));
    }
}
How to run:
You need to use an HTML file to load applet (for older systems).
________________________________________
🔷 AWT Layout Managers
Layout Manager decide karta hai कि components container में कैसे दिखेंगे।
Layout	Description
FlowLayout	Left to right
BorderLayout	North, South, East, West, Center
GridLayout	Grid style
CardLayout	One at a time
null layout	Manually set position using setBounds()
________________________________________
🟩 Summary (AWT के फायदे):
•	GUI बनाना आसान
•	Platform-independent
•	Code reusability via components
•	Visual representation of user interface
🟩 Introduction to AWT UI Controls
🔹 AWT (Abstract Window Toolkit) Java की एक toolkit है जिसका use GUI (Graphical User Interface) या windows-based applications बनाने के लिए किया जाता है.
🔹 AWT का part है: java.awt package, जिसमें बहुत सारे pre-built classes होती हैं जैसे:
•	TextField
•	Label
•	Button
•	Checkbox
•	TextArea
•	RadioButton
•	List
•	Choice (drop-down)
✳️ Platform Dependent
AWT components platform-dependent होते हैं — मतलब उनका look and feel उस OS के हिसाब से होता है जिस पर app चल रही है.
🧠 For Example:
•	Windows में AWT का Button Windows जैसे दिखेगा,
•	Mac में Mac जैसा दिखेगा.
क्योंकि AWT native OS की subroutines को call करता है — यानी वो same component आपके OS के default graphics से draw होता है.
________________________________________
🟩 AWT Components / Controls
Control	Use (उपयोग)
Label	Static text दिखाने के लिए
Button	किसी action के लिए क्लिक करने वाला बटन
TextField	Single-line user input के लिए
TextArea	Multi-line text input
Checkbox	Multiple options में से select करने के लिए
RadioButton	CheckboxGroup के साथ use होता है (single choice)
Choice	Drop-down menu
List	List box में multiple items
Scrollbar	Scroll करने के लिए
________________________________________
🟨 AWT Hierarchy (Class Structure)
AWT की class hierarchy नीचे दी गई है:
java.lang.Object
    └── java.awt.Component
          ├── Button
          ├── Label
          ├── Checkbox
          ├── TextField
          ├── TextArea
          ├── List
          ├── Choice
          └── Container
                └── Window
                      ├── Frame
                      ├── Dialog
                      └── Applet
                          └── Panel
🔍 Breakdown:
•	Component: Base class for all UI elements.
•	Container: वह class जो other components को contain कर सकती है.
•	Window: Top-level container, जैसे कि Frame, Dialog.
•	Frame: Main application window.
•	Panel: Sub-container, जिसमें आप components रख सकते हैं.
•	Applet: Web-based GUI applications.
________________________________________
🟩 Features of AWT UI Controls
1.	✅ Platform Dependent
हर OS पर component का look and feel अलग हो सकता है।
2.	🧱 Heavyweight Components
ये native OS resources का use करते हैं, इसलिए इन्हें heavyweight कहा जाता है।
3.	🔄 Reusable and Object-Oriented
हर component एक class है, जिसे आप object की तरह use कर सकते हैं और reuse भी कर सकते हैं।
4.	🛠️ Event Handling Supported
Button क्लिक, mouse move, key press जैसे events को handle करने के लिए AWT में event-handling model है।
5.	🔗 Integrated with Layout Managers
Components को automatically arrange करने के लिए FlowLayout, GridLayout, etc. layouts का support है।
________________________________________
🧾 Simple Example with UI Controls
import java.awt.*;

public class MyAWTDemo {
    public static void main(String[] args) {
        Frame f = new Frame("AWT Example");

        Label l = new Label("Enter Name:");
        l.setBounds(50, 50, 100, 30);

        TextField tf = new TextField();
        tf.setBounds(160, 50, 150, 30);

        Button b = new Button("Submit");
        b.setBounds(120, 100, 80, 30);

        f.add(l);
        f.add(tf);
        f.add(b);

        f.setSize(400, 200);
        f.setLayout(null);
        f.setVisible(true);
    }
}
👁️ Output: A basic window with a label, text field and button.
________________________________________
📌 Summary
Feature	Detail
Platform	Dependent (native look)
Components	Button, Label, TextField, etc.
Container	Frame, Dialog, Panel
Hierarchy	Based on Object → Component → Container
Usage	GUI apps in desktop or applet form
Drawback	Heavyweight; Swing is more modern
📌 Introduction to Event Handling (Java AWT)
🔷 Event क्या होता है?
Jab kisi object ka state change hota hai, use event kehte hain.
👉 Jaise:
•	Button click करना
•	Keyboard से key दबाना
•	Mouse को move करना
•	List में से item select करना
ये sab actions event generate करते हैं.
________________________________________
🔷 Types of Events
1.	Foreground Events
वो events जो user के direct interaction से होते हैं।
🔸 Example: Button पर click करना, key दबाना, mouse को move करना etc.
2.	Background Events
वो events जो बिना user के interaction के होते हैं।
🔸 Example: System का interrupt आना, timer expire होना, software crash होना etc.
________________________________________
🔷 Event Handling क्या है?
Event Handling का मतलब है — jab koi event hota है, to uske response में क्या करना है, वो decide करना और execute करना।
Java में event handle करने के लिए ek model use होता है:
👉 Delegation Event Model
________________________________________
🔷 Delegation Event Model – Key Components
1.	Source – वो object जिस पर event होता है (जैसे button).
Source responsible होता है event की information listener को देने के लिए.
2.	Listener – Listener वो object होता है जो event के आने का wait करता है.
Jab event आता है, तो listener response देता है – यही code "event handler" होता है.
📌 Important Point:
Source object को listener के साथ register करना ज़रूरी होता है, tabhi listener ko notification मिलेगा.
________________________________________
🔷 Callback Methods
Ye wo methods hote hain jo listener interfaces में defined होते हैं.
Java जब event detect करता है to callback method call karta hai.
Agar aap listener class banana चाहते हैं to aapko listener interface implement करना पड़ेगा, जैसे:
•	ActionListener
•	MouseListener
•	KeyListener etc.
________________________________________
✅ Steps of Event Handling:
1.	User button पर click करता है → event generate होता है.
2.	Event object automatically create होता है.
3.	Listener method call होता है (callback).
4.	उस method में जो code है वो run होता है.
________________________________________
💻 Java AWT Event Handling Example:
import java.awt.*;
import java.awt.event.*;

public class AwtControlDemo {
    private Frame mainFrame;
    private Label headerLabel;
    private Label statusLabel;
    private Panel controlPanel;

    public AwtControlDemo() {
        prepareGUI();
    }

    public static void main(String[] args) {
        AwtControlDemo demo = new AwtControlDemo();
        demo.showEventDemo();
    }

    private void prepareGUI() {
        mainFrame = new Frame("Java AWT Examples");
        mainFrame.setSize(400, 400);
        mainFrame.setLayout(new GridLayout(3, 1));

        mainFrame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent windowEvent) {
                System.exit(0);
            }
        });

        headerLabel = new Label();
        headerLabel.setAlignment(Label.CENTER);

        statusLabel = new Label();
        statusLabel.setAlignment(Label.CENTER);
        statusLabel.setSize(350, 100);

        controlPanel = new Panel();
        controlPanel.setLayout(new FlowLayout());

        mainFrame.add(headerLabel);
        mainFrame.add(controlPanel);
        mainFrame.add(statusLabel);
        mainFrame.setVisible(true);
    }

    private void showEventDemo() {
        headerLabel.setText("Control in action: Button");

        Button okButton = new Button("OK");
        Button submitButton = new Button("Submit");
        Button cancelButton = new Button("Cancel");

        okButton.setActionCommand("OK");
        submitButton.setActionCommand("Submit");
        cancelButton.setActionCommand("Cancel");

        okButton.addActionListener(new ButtonClickListener());
        submitButton.addActionListener(new ButtonClickListener());
        cancelButton.addActionListener(new ButtonClickListener());

        controlPanel.add(okButton);
        controlPanel.add(submitButton);
        controlPanel.add(cancelButton);

        mainFrame.setVisible(true);
    }

    private class ButtonClickListener implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            String command = e.getActionCommand();

            if (command.equals("OK")) {
                statusLabel.setText("OK Button clicked.");
            } else if (command.equals("Submit")) {
                statusLabel.setText("Submit Button clicked.");
            } else {
                statusLabel.setText("Cancel Button clicked.");
            }
        }
    }
}
________________________________________
📝 Output (Expected):
जब आप कोई button click करेंगे, label में message आएगा:
OK Button clicked.
Submit Button clicked.
Cancel Button clicked.
🎯 Introduction to Event Handling Classes (Java AWT)
🔷 EventObject Class – क्या होता है?
•	यह Java में event hierarchy की root class होती है।
•	Java में jitne भी events होते हैं, unka state/event data yahi class store करती है.
•	Jab bhi koi event hota hai (like button click), Java ek object create karta hai jisme event की सारी information होती है – उस object का base class hota है EventObject.
📦 Ye class defined hai java.util package में.
________________________________________
✅ Class Declaration:
public class EventObject extends Object implements Serializable
________________________________________
🧱 Field:
protected Object source;
•	source – यह वह object होता है जिस पर event हुआ था।
(e.g. अगर button पर click हुआ है, तो source वो button object होगा)
________________________________________
🏗️ Constructor:
EventObject(Object source)
•	Is constructor में आप pass करते हो – वो object जिस पर event हुआ था.
•	Ye constructor एक basic event object बनाता है.
________________________________________
🛠️ Commonly Used Methods:
Method	Description
Object getSource()	वो object return करता है जिस पर event हुआ था.
String toString()	event object की string format में info return करता है.
________________________________________
🔁 Inherited Methods:
EventObject class inherit करती है methods from:
•	java.lang.Object
________________________________________
🧩 AWT Event Classes
Java AWT में kai tarah के events होते हैं, jinke लिए अलग-अलग event classes defined होती हैं. नीचे कुछ commonly used event classes दी गई हैं:
________________________________________
1️⃣ AWTEvent
•	ये AWT events की root class होती है.
•	पुरानी java.awt.Event class को replace करने के लिए introduce किया गया था.
________________________________________
2️⃣ ActionEvent
•	Jab user button पर click करता है ya list का item select करता है, tab ye event generate होता है.
📌 Use with: Button, MenuItem, List
________________________________________
3️⃣ InputEvent
•	ये एक superclass है input-related events का (keyboard, mouse etc.).
•	Isse extend karke aur specific events banते हैं.
________________________________________
4️⃣ KeyEvent
•	Jab user keyboard se koi key press ya release karta hai, tab ye event fire hota है.
📌 Use with: TextField, TextArea, Canvas etc.
________________________________________
5️⃣ MouseEvent
•	Jab mouse se koi action hota है (click, move, drag, etc), tab ye event generate hota है.
📌 Use with: Almost any GUI component like Panel, Frame, etc.
________________________________________
🔚 Summary (सारांश):
•	EventObject – हर event का base class है.
•	AWT में हर interaction के लिए ek specific event class होती है:
o	Button → ActionEvent
o	Key press → KeyEvent
o	Mouse click → MouseEvent etc.
•	Ye saare events Delegation Event Model ke through handle होते हैं.
🎯 Introduction to Event Listener Interfaces in Java
Java में जब भी user कोई action perform करता है (जैसे button click, key press, mouse move), तो उसके लिए एक event generate होता है।
इन events को handle करने के लिए Java ने Event Listener Interfaces provide किए हैं।
________________________________________
🔹 Event Listener क्या है?
•	Event Listener वो interface होता है जो event को सुनता है और handle करता है।
•	Java में har listener ek specific type का event handle करता है – जैसे:
o	Button click → ActionListener
o	Key press → KeyListener
o	Mouse click → MouseListener
👉 इन सभी listener interfaces के methods का एक ही parameter होता है, जो कि EventObject का subclass होता है।
जैसे:
MouseListener के methods को call करने पर, वो एक MouseEvent object receive करता है (जो EventObject से derive होता है)।
________________________________________
📦 EventListener Interface (Base Interface)
•	ये एक marker interface है (मतलब इसमें कोई method नहीं होता).
•	Java में jitne bhi listener interfaces hain, वो sab EventListener interface को extend करते हैं.
•	ये interface java.util package में defined है।
✅ Declaration:
public interface EventListener
________________________________________
🔁 Commonly Used AWT Event Listener Interfaces:
नीचे कुछ important और frequently used Event Listener interfaces दिए गए हैं:
No.	Interface Name	Description
1️⃣	ActionListener	जब user किसी button को click करता है या कोई action perform करता है, तब ये interface काम आता है।
2️⃣	ComponentListener	किसी component की visibility या size change होती है, तो ये events trigger होते हैं।
3️⃣	ItemListener	जब किसी Checkbox या Choice का state change होता है (select/unselect), तब ये use होता है।
4️⃣	KeyListener	जब user keyboard की कोई key press, release या type करता है, तो ये interface use होता है।
5️⃣	MouseListener	Mouse click, enter, exit, press, release जैसे events handle करता है।
6️⃣	TextListener	जब text field का content change होता है, तो ये listener trigger होता है।
7️⃣	WindowListener	जब window open, close, minimize, maximize होता है, तो ये events trigger होते हैं।
________________________________________
🧠 Summary (सारांश):
•	Java AWT में हर तरह के GUI interaction के लिए एक specific listener interface होता है।
•	हर listener interface एक particular type का event सुनता है और handle करता है।
•	सभी listener interfaces EventListener interface को extend करते हैं।
•	Listener के method में event object parameter होता है, जो EventObject class का subclass होता है।
🧱 Introduction to AWT Layouts (लेआउट्स का परिचय)
📌 What is Layout? (Layout क्या होता है?)
Layout का मतलब होता है — किसी container (जैसे Frame, Panel, आदि) के अंदर components (जैसे Button, Label, TextField) को सही position पर रखना।
➡️ Java में Layout को manage करने का काम Layout Manager करता है।
________________________________________
🧰 Layout Manager क्या है?
•	Layout Manager एक Java object होता है जो container के अंदर components को automatically arrange करता है।
•	अगर आप कोई layout manager explicitly set नहीं करते, तो Java एक default layout manager use करता है।
⚠️ अगर आप manually layout करें:
Manually controls को position करना possible तो है, लेकिन ये मुश्किल होता है, क्योंकि:
1.	अगर components ज़्यादा हो जाएं तो उनका manage करना कठिन हो जाता है।
2.	कभी-कभी component की width और height की जानकारी उपलब्ध नहीं होती।
________________________________________
🔄 Java में Layout Manager की विशेषताएँ
•	Layout Manager हर Container object से जुड़ा होता है।
•	Java में layout manager की functionality को handle करने के लिए दो interfaces होते हैं:
Interface	Description
LayoutManager	इसमें वो methods होते हैं जो किसी class को layout manager बनने के लिए implement करने होते हैं।
LayoutManager2	ये LayoutManager का sub-interface है और advance layout constraints को support करता है।
________________________________________
🧱 Commonly Used AWT Layout Managers (LayoutManager Classes)
Layout Manager	Description (Hindi में)
1. BorderLayout	ये layout components को पाँच हिस्सों में arrange करता है – North, South, East, West, और Center।
2. CardLayout	ये layout components को "cards" की तरह treat करता है — एक समय में सिर्फ एक ही component (card) visible होता है।
3. FlowLayout	ये layout components को left to right horizontal row में flow के हिसाब से arrange करता है (default layout)।
4. GridLayout	ये layout components को एक rectangular grid (rows × columns) में arrange करता है। सभी cells समान आकार के होते हैं।
5. GridBagLayout	ये सबसे flexible layout manager है। इसमें आप components को vertical, horizontal या baseline के अनुसार align कर सकते हैं, और सभी component एक जैसे size के नहीं होते।
________________________________________
🧠 Summary (सारांश):
•	Java AWT में layout manager automatically controls को arrange करता है।
•	Layout manager responsive होते हैं — जैसे ही application window का size change होता है, layout भी adapt हो जाता है।
•	Java में अलग-अलग प्रकार के layout managers दिए गए हैं जो अलग-अलग तरीके से components को arrange करते हैं:
o	Simple: FlowLayout, BorderLayout
o	Structured: GridLayout
o	Advanced: CardLayout, GridBagLayout


    </textarea>
  </div>
<a href="theory6_i.html">
  <button style="
    background-color: #4CAF50; /* Green */
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s ease, transform 0.2s ease;
  ">
    Take Test
  </button>
</a>
  <script>
    function escapeHTML(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    document.addEventListener("DOMContentLoaded", () => {
      const raw = document.getElementById("raw-input").value;
      document.getElementById("output").innerHTML = escapeHTML(raw);
    });
  </script>
</body>
</html>
